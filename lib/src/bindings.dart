/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2019, assimp team

All rights reserved.
...
*/
// @dart=3.0
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// The Open-Asset-Importer-Lib
class LibAssimp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibAssimp(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibAssimp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  late final ffi.Pointer<ffi.Double> __HUGE = _lookup<ffi.Double>('_HUGE');

  double get _HUGE => __HUGE.value;

  late final ffi.Pointer<_float_const> __Denorm_C =
      _lookup<_float_const>('_Denorm_C');

  ffi.Pointer<_float_const> get _Denorm_C => __Denorm_C;

  late final ffi.Pointer<_float_const> __Inf_C =
      _lookup<_float_const>('_Inf_C');

  ffi.Pointer<_float_const> get _Inf_C => __Inf_C;

  late final ffi.Pointer<_float_const> __Nan_C =
      _lookup<_float_const>('_Nan_C');

  ffi.Pointer<_float_const> get _Nan_C => __Nan_C;

  late final ffi.Pointer<_float_const> __Snan_C =
      _lookup<_float_const>('_Snan_C');

  ffi.Pointer<_float_const> get _Snan_C => __Snan_C;

  late final ffi.Pointer<_float_const> __Hugeval_C =
      _lookup<_float_const>('_Hugeval_C');

  ffi.Pointer<_float_const> get _Hugeval_C => __Hugeval_C;

  late final ffi.Pointer<_float_const> __FDenorm_C =
      _lookup<_float_const>('_FDenorm_C');

  ffi.Pointer<_float_const> get _FDenorm_C => __FDenorm_C;

  late final ffi.Pointer<_float_const> __FInf_C =
      _lookup<_float_const>('_FInf_C');

  ffi.Pointer<_float_const> get _FInf_C => __FInf_C;

  late final ffi.Pointer<_float_const> __FNan_C =
      _lookup<_float_const>('_FNan_C');

  ffi.Pointer<_float_const> get _FNan_C => __FNan_C;

  late final ffi.Pointer<_float_const> __FSnan_C =
      _lookup<_float_const>('_FSnan_C');

  ffi.Pointer<_float_const> get _FSnan_C => __FSnan_C;

  late final ffi.Pointer<_float_const> __LDenorm_C =
      _lookup<_float_const>('_LDenorm_C');

  ffi.Pointer<_float_const> get _LDenorm_C => __LDenorm_C;

  late final ffi.Pointer<_float_const> __LInf_C =
      _lookup<_float_const>('_LInf_C');

  ffi.Pointer<_float_const> get _LInf_C => __LInf_C;

  late final ffi.Pointer<_float_const> __LNan_C =
      _lookup<_float_const>('_LNan_C');

  ffi.Pointer<_float_const> get _LNan_C => __LNan_C;

  late final ffi.Pointer<_float_const> __LSnan_C =
      _lookup<_float_const>('_LSnan_C');

  ffi.Pointer<_float_const> get _LSnan_C => __LSnan_C;

  late final ffi.Pointer<_float_const> __Eps_C =
      _lookup<_float_const>('_Eps_C');

  ffi.Pointer<_float_const> get _Eps_C => __Eps_C;

  late final ffi.Pointer<_float_const> __Rteps_C =
      _lookup<_float_const>('_Rteps_C');

  ffi.Pointer<_float_const> get _Rteps_C => __Rteps_C;

  late final ffi.Pointer<_float_const> __FEps_C =
      _lookup<_float_const>('_FEps_C');

  ffi.Pointer<_float_const> get _FEps_C => __FEps_C;

  late final ffi.Pointer<_float_const> __FRteps_C =
      _lookup<_float_const>('_FRteps_C');

  ffi.Pointer<_float_const> get _FRteps_C => __FRteps_C;

  late final ffi.Pointer<_float_const> __LEps_C =
      _lookup<_float_const>('_LEps_C');

  ffi.Pointer<_float_const> get _LEps_C => __LEps_C;

  late final ffi.Pointer<_float_const> __LRteps_C =
      _lookup<_float_const>('_LRteps_C');

  ffi.Pointer<_float_const> get _LRteps_C => __LRteps_C;

  late final ffi.Pointer<ffi.Double> __Zero_C = _lookup<ffi.Double>('_Zero_C');

  double get _Zero_C => __Zero_C.value;

  late final ffi.Pointer<ffi.Double> __Xbig_C = _lookup<ffi.Double>('_Xbig_C');

  double get _Xbig_C => __Xbig_C.value;

  late final ffi.Pointer<ffi.Float> __FZero_C = _lookup<ffi.Float>('_FZero_C');

  double get _FZero_C => __FZero_C.value;

  late final ffi.Pointer<ffi.Float> __FXbig_C = _lookup<ffi.Float>('_FXbig_C');

  double get _FXbig_C => __FXbig_C.value;

  late final ffi.Pointer<ffi.Double> _HUGE$1 = _lookup<ffi.Double>('HUGE');

  double get HUGE => _HUGE$1.value;

  set HUGE(double value) => _HUGE$1.value = value;

  /// @brief  Get a string for a given aiTextureType
  ///
  /// @param  in  The texture type
  /// @return The description string for the texture type.
  ffi.Pointer<ffi.Char> aiTextureTypeToString(
    aiTextureType in$,
  ) {
    return _aiTextureTypeToString(
      in$.value,
    );
  }

  late final _aiTextureTypeToStringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'aiTextureTypeToString');
  late final _aiTextureTypeToString = _aiTextureTypeToStringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @brief Retrieve a material property with a specific key from the material
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param type Specifies the type of the texture to be retrieved (
  /// e.g. diffuse, specular, height map ...)
  /// @param index Index of the texture to be retrieved.
  /// @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
  /// structure or NULL if the key has not been found.
  aiReturn aiGetMaterialProperty(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
  ) {
    return aiReturn.fromValue(_aiGetMaterialProperty(
      pMat,
      pKey,
      type,
      index,
      pPropOut,
    ));
  }

  late final _aiGetMaterialPropertyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<aiMaterial>,
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>>(
      'aiGetMaterialProperty');
  late final _aiGetMaterialProperty = _aiGetMaterialPropertyPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<aiMaterialProperty>>)>();

  /// @brief Retrieve an array of float values with a specific key
  /// from the material
  ///
  /// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
  /// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)
  /// @code
  /// aiUVTransform trafo;
  /// unsigned int max = sizeof(aiUVTransform);
  /// if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),
  /// (float*)&trafo, &max) || sizeof(aiUVTransform) != max)
  /// {
  /// // error handling
  /// }
  /// @endcode
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param pOut Pointer to a buffer to receive the result.
  /// @param pMax Specifies the size of the given buffer, in float's.
  /// Receives the number of values (not bytes!) read.
  /// @param type (see the code sample above)
  /// @param index (see the code sample above)
  /// @return Specifies whether the key has been found. If not, the output
  /// arrays remains unmodified and pMax is set to 0.
  aiReturn aiGetMaterialFloatArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ai_real> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return aiReturn.fromValue(_aiGetMaterialFloatArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    ));
  }

  late final _aiGetMaterialFloatArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialFloatArray');
  late final _aiGetMaterialFloatArray = _aiGetMaterialFloatArrayPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ai_real>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Retrieve an array of integer values with a specific key
  /// from a material
  ///
  /// See the sample for aiGetMaterialFloatArray for more information.
  aiReturn aiGetMaterialIntegerArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Int> pOut,
    ffi.Pointer<ffi.UnsignedInt> pMax,
  ) {
    return aiReturn.fromValue(_aiGetMaterialIntegerArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    ));
  }

  late final _aiGetMaterialIntegerArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialIntegerArray');
  late final _aiGetMaterialIntegerArray =
      _aiGetMaterialIntegerArrayPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Retrieve a color value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  aiReturn aiGetMaterialColor(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiColor4D> pOut,
  ) {
    return aiReturn.fromValue(_aiGetMaterialColor(
      pMat,
      pKey,
      type,
      index,
      pOut,
    ));
  }

  late final _aiGetMaterialColorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiColor4D>)>>('aiGetMaterialColor');
  late final _aiGetMaterialColor = _aiGetMaterialColorPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiColor4D>)>();

  /// @brief Retrieve a aiUVTransform value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  aiReturn aiGetMaterialUVTransform(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiUVTransform> pOut,
  ) {
    return aiReturn.fromValue(_aiGetMaterialUVTransform(
      pMat,
      pKey,
      type,
      index,
      pOut,
    ));
  }

  late final _aiGetMaterialUVTransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiUVTransform>)>>('aiGetMaterialUVTransform');
  late final _aiGetMaterialUVTransform =
      _aiGetMaterialUVTransformPtr.asFunction<
          int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<aiUVTransform>)>();

  /// @brief Retrieve a string from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information.
  aiReturn aiGetMaterialString(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Char> pKey,
    int type,
    int index,
    ffi.Pointer<aiString> pOut,
  ) {
    return aiReturn.fromValue(_aiGetMaterialString(
      pMat,
      pKey,
      type,
      index,
      pOut,
    ));
  }

  late final _aiGetMaterialStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>)>>('aiGetMaterialString');
  late final _aiGetMaterialString = _aiGetMaterialStringPtr.asFunction<
      int Function(ffi.Pointer<aiMaterial>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<aiString>)>();

  /// Get the number of textures for a particular texture type.
  /// @param[in] pMat Pointer to the input material. May not be NULL
  /// @param type Texture type to check for
  /// @return Number of textures for this type.
  /// @note A texture can be easily queried using #aiGetMaterialTexture()
  int aiGetMaterialTextureCount(
    ffi.Pointer<aiMaterial> pMat,
    aiTextureType type,
  ) {
    return _aiGetMaterialTextureCount(
      pMat,
      type.value,
    );
  }

  late final _aiGetMaterialTextureCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<aiMaterial>,
              ffi.UnsignedInt)>>('aiGetMaterialTextureCount');
  late final _aiGetMaterialTextureCount = _aiGetMaterialTextureCountPtr
      .asFunction<int Function(ffi.Pointer<aiMaterial>, int)>();

  aiReturn aiGetMaterialTexture(
    ffi.Pointer<aiMaterial> mat,
    aiTextureType type,
    int index,
    ffi.Pointer<aiString> path,
    ffi.Pointer<ffi.UnsignedInt> mapping,
    ffi.Pointer<ffi.UnsignedInt> uvindex,
    ffi.Pointer<ai_real> blend,
    ffi.Pointer<ffi.UnsignedInt> op,
    ffi.Pointer<ffi.UnsignedInt> mapmode,
    ffi.Pointer<ffi.UnsignedInt> flags,
  ) {
    return aiReturn.fromValue(_aiGetMaterialTexture(
      mat,
      type.value,
      index,
      path,
      mapping,
      uvindex,
      blend,
      op,
      mapmode,
      flags,
    ));
  }

  late final _aiGetMaterialTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiMaterial>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<aiString>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('aiGetMaterialTexture');
  late final _aiGetMaterialTexture = _aiGetMaterialTexturePtr.asFunction<
      int Function(
          ffi.Pointer<aiMaterial>,
          int,
          int,
          ffi.Pointer<aiString>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ai_real>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Returns the number of export file formats available in the current Assimp build.
  /// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.
  int aiGetExportFormatCount() {
    return _aiGetExportFormatCount();
  }

  late final _aiGetExportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetExportFormatCount');
  late final _aiGetExportFormatCount =
      _aiGetExportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth export file format. Use #aiGetExportFormatCount()
  /// to learn how many export formats are supported. The description must be released by
  /// calling aiReleaseExportFormatDescription afterwards.
  /// @param pIndex Index of the export format to retrieve information for. Valid range is
  /// 0 to #aiGetExportFormatCount()
  /// @return A description of that specific export format. NULL if pIndex is out of range.
  ffi.Pointer<aiExportFormatDesc> aiGetExportFormatDescription(
    int pIndex,
  ) {
    return _aiGetExportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetExportFormatDescriptionPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<aiExportFormatDesc> Function(ffi.Size)>>(
      'aiGetExportFormatDescription');
  late final _aiGetExportFormatDescription = _aiGetExportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiExportFormatDesc> Function(int)>();

  /// Release a description of the nth export file format. Must be returned by
  /// aiGetExportFormatDescription
  /// @param desc Pointer to the description
  void aiReleaseExportFormatDescription(
    ffi.Pointer<aiExportFormatDesc> desc,
  ) {
    return _aiReleaseExportFormatDescription(
      desc,
    );
  }

  late final _aiReleaseExportFormatDescriptionPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<aiExportFormatDesc>)>>(
      'aiReleaseExportFormatDescription');
  late final _aiReleaseExportFormatDescription =
      _aiReleaseExportFormatDescriptionPtr
          .asFunction<void Function(ffi.Pointer<aiExportFormatDesc>)>();

  /// Create a modifiable copy of a scene.
  /// This is useful to import files via Assimp, change their topology and
  /// export them again. Since the scene returned by the various importer functions
  /// is const, a modifiable copy is needed.
  /// @param pIn Valid scene to be copied
  /// @param pOut Receives a modifiable copy of the scene. Use aiFreeScene() to
  /// delete it again.
  void aiCopyScene(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<ffi.Pointer<aiScene>> pOut,
  ) {
    return _aiCopyScene(
      pIn,
      pOut,
    );
  }

  late final _aiCopyScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Pointer<aiScene>>)>>('aiCopyScene');
  late final _aiCopyScene = _aiCopyScenePtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Pointer<aiScene>>)>();

  /// Frees a scene copy created using aiCopyScene()
  void aiFreeScene(
    ffi.Pointer<aiScene> pIn,
  ) {
    return _aiFreeScene(
      pIn,
    );
  }

  late final _aiFreeScenePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiFreeScene');
  late final _aiFreeScene =
      _aiFreeScenePtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Exports the given scene to a chosen file format and writes the result file(s) to disk.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// The scene is expected to conform to Assimp's Importer output format as specified
  /// in the @link data Data Structures Page @endlink. In short, this means the model data
  /// should use a right-handed coordinate systems, face winding should be counter-clockwise
  /// and the UV coordinate origin is assumed to be in the upper left. If your input data
  /// uses different conventions, have a look at the last parameter.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
  /// flags, but in reality only a subset of them makes sense here. Specifying
  /// 'preprocessing' flags is useful if the input scene does not conform to
  /// Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
  /// In short, this means the geometry data should use a right-handed coordinate systems, face
  /// winding should be counter-clockwise and the UV coordinate origin is assumed to be in
  /// the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder flags are used in the import side to allow users
  /// to have those defaults automatically adapted to their conventions. Specifying those flags
  /// for exporting has the opposite effect, respectively. Some other of the
  /// #aiPostProcessSteps enumerated values may be useful as well, but you'll need
  /// to try out what their effect on the exported file is. Many formats impose
  /// their own restrictions on the structure of the geometry stored therein,
  /// so some preprocessing may have little or no effect at all, or may be
  /// redundant as exporters would apply them anyhow. A good example
  /// is triangulation - whilst you can enforce it by specifying
  /// the #aiProcess_Triangulate flag, most export formats support only
  /// triangulate data so they would run the step anyway.
  ///
  /// If assimp detects that the input scene was directly taken from the importer side of
  /// the library (i.e. not copied using aiCopyScene and potentially modified afterwards),
  /// any post-processing steps already applied to the scene will not be applied again, unless
  /// they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder).
  /// @return a status code indicating the result of the export
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  aiReturn aiExportScene(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    int pPreprocessing,
  ) {
    return aiReturn.fromValue(_aiExportScene(
      pScene,
      pFormatId,
      pFileName,
      pPreprocessing,
    ));
  }

  late final _aiExportScenePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportScene');
  late final _aiExportScene = _aiExportScenePtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Exports the given scene to a chosen file format using custom IO logic supplied by you.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pIO custom IO implementation to be used. Use this if you use your own storage methods.
  /// If none is supplied, a default implementation using standard file IO is used. Note that
  /// #aiExportSceneToBlob is provided as convenience function to export to memory buffers.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return a status code indicating the result of the export
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  aiReturn aiExportSceneEx(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    ffi.Pointer<ffi.Char> pFileName,
    ffi.Pointer<aiFileIO> pIO,
    int pPreprocessing,
  ) {
    return aiReturn.fromValue(_aiExportSceneEx(
      pScene,
      pFormatId,
      pFileName,
      pIO,
      pPreprocessing,
    ));
  }

  late final _aiExportSceneExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiFileIO>,
              ffi.UnsignedInt)>>('aiExportSceneEx');
  late final _aiExportSceneEx = _aiExportSceneExPtr.asFunction<
      int Function(ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<aiFileIO>, int)>();

  /// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which
  /// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()
  /// to free the resources associated with the export.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return the exported data or NULL in case of error
  ffi.Pointer<aiExportDataBlob> aiExportSceneToBlob(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Char> pFormatId,
    int pPreprocessing,
  ) {
    return _aiExportSceneToBlob(
      pScene,
      pFormatId,
      pPreprocessing,
    );
  }

  late final _aiExportSceneToBlobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiExportDataBlob> Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiExportSceneToBlob');
  late final _aiExportSceneToBlob = _aiExportSceneToBlobPtr.asFunction<
      ffi.Pointer<aiExportDataBlob> Function(
          ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>, int)>();

  /// Releases the memory associated with the given exported data. Use this function to free a data blob
  /// returned by aiExportScene().
  /// @param pData the data blob returned by #aiExportSceneToBlob
  void aiReleaseExportBlob(
    ffi.Pointer<aiExportDataBlob> pData,
  ) {
    return _aiReleaseExportBlob(
      pData,
    );
  }

  late final _aiReleaseExportBlobPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiExportDataBlob>)>>(
      'aiReleaseExportBlob');
  late final _aiReleaseExportBlob = _aiReleaseExportBlobPtr
      .asFunction<void Function(ffi.Pointer<aiExportDataBlob>)>();

  /// \brief  Returns the Importer description for a given extension.
  ///
  /// Will return a nullptr if no assigned importer desc. was found for the given extension
  /// \param  extension   [in] The extension to look for
  /// \return A pointer showing to the ImporterDesc, \see aiImporterDesc.
  ffi.Pointer<aiImporterDesc> aiGetImporterDesc(
    ffi.Pointer<ffi.Char> extension$,
  ) {
    return _aiGetImporterDesc(
      extension$,
    );
  }

  late final _aiGetImporterDescPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiImporterDesc> Function(
              ffi.Pointer<ffi.Char>)>>('aiGetImporterDesc');
  late final _aiGetImporterDesc = _aiGetImporterDescPtr.asFunction<
      ffi.Pointer<aiImporterDesc> Function(ffi.Pointer<ffi.Char>)>();

  /// Reads the given file and returns its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @return Pointer to the imported data or NULL if the import failed.
  ffi.Pointer<aiScene> aiImportFile(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
  ) {
    return _aiImportFile(
      pFile,
      pFlags,
    );
  }

  late final _aiImportFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('aiImportFile');
  late final _aiImportFile = _aiImportFilePtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Reads the given file using user-defined I/O functions and returns
  /// its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  ffi.Pointer<aiScene> aiImportFileEx(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
  ) {
    return _aiImportFileEx(
      pFile,
      pFlags,
      pFS,
    );
  }

  late final _aiImportFileExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>)>>('aiImportFileEx');
  late final _aiImportFileEx = _aiImportFileExPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<aiFileIO>)>();

  /// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
  ///
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @see aiImportFileEx
  ffi.Pointer<aiScene> aiImportFileExWithProperties(
    ffi.Pointer<ffi.Char> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileExWithProperties(
      pFile,
      pFlags,
      pFS,
      pProps,
    );
  }

  late final _aiImportFileExWithPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<aiFileIO>,
              ffi.Pointer<aiPropertyStore>)>>('aiImportFileExWithProperties');
  late final _aiImportFileExWithProperties =
      _aiImportFileExWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<aiFileIO>, ffi.Pointer<aiPropertyStore>)>();

  /// Reads the given file from a given memory buffer,
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned.
  /// A human-readable error description can be retrieved by calling aiGetErrorString().
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  ffi.Pointer<aiScene> aiImportFileFromMemory(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
  ) {
    return _aiImportFileFromMemory(
      pBuffer,
      pLength,
      pFlags,
      pHint,
    );
  }

  late final _aiImportFileFromMemoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('aiImportFileFromMemory');
  late final _aiImportFileFromMemory = _aiImportFileFromMemoryPtr.asFunction<
      ffi.Pointer<aiScene> Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  /// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
  ///
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  /// @see aiImportFileFromMemory
  ffi.Pointer<aiScene> aiImportFileFromMemoryWithProperties(
    ffi.Pointer<ffi.Char> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Char> pHint,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileFromMemoryWithProperties(
      pBuffer,
      pLength,
      pFlags,
      pHint,
      pProps,
    );
  }

  late final _aiImportFileFromMemoryWithPropertiesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<aiScene> Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.UnsignedInt,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<aiPropertyStore>)>>(
      'aiImportFileFromMemoryWithProperties');
  late final _aiImportFileFromMemoryWithProperties =
      _aiImportFileFromMemoryWithPropertiesPtr.asFunction<
          ffi.Pointer<aiScene> Function(ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<aiPropertyStore>)>();

  /// Apply post-processing to an already-imported scene.
  ///
  /// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
  /// same flags. However, you can use this separate function to inspect the imported
  /// scene first to fine-tune your post-processing setup.
  /// @param pScene Scene to work on.
  /// @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
  /// @return A pointer to the post-processed data. Post processing is done in-place,
  /// meaning this is still the same #aiScene which you passed for pScene. However,
  /// _if_ post-processing failed, the scene could now be NULL. That's quite a rare
  /// case, post processing steps are not really designed to 'fail'. To be exact,
  /// the #aiProcess_ValidateDataStructure flag is currently the only post processing step
  /// which can actually cause the scene to be reset to NULL.
  ffi.Pointer<aiScene> aiApplyPostProcessing(
    ffi.Pointer<aiScene> pScene,
    int pFlags,
  ) {
    return _aiApplyPostProcessing(
      pScene,
      pFlags,
    );
  }

  late final _aiApplyPostProcessingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiScene> Function(
              ffi.Pointer<aiScene>, ffi.UnsignedInt)>>('aiApplyPostProcessing');
  late final _aiApplyPostProcessing = _aiApplyPostProcessingPtr
      .asFunction<ffi.Pointer<aiScene> Function(ffi.Pointer<aiScene>, int)>();

  /// Get one of the predefine log streams. This is the quick'n'easy solution to
  /// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
  /// overall import performance.
  ///
  /// Usage is rather simple (this will stream the log to a file, named log.txt, and
  /// the stdout stream of the process:
  /// @code
  /// struct aiLogStream c;
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
  /// aiAttachLogStream(&c);
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
  /// aiAttachLogStream(&c);
  /// @endcode
  ///
  /// @param pStreams One of the #aiDefaultLogStream enumerated values.
  /// @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
  /// Pass NULL for all other flags.
  /// @return The log stream. callback is set to NULL if something went wrong.
  aiLogStream aiGetPredefinedLogStream(
    aiDefaultLogStream pStreams,
    ffi.Pointer<ffi.Char> file,
  ) {
    return _aiGetPredefinedLogStream(
      pStreams.value,
      file,
    );
  }

  late final _aiGetPredefinedLogStreamPtr = _lookup<
      ffi.NativeFunction<
          aiLogStream Function(ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('aiGetPredefinedLogStream');
  late final _aiGetPredefinedLogStream = _aiGetPredefinedLogStreamPtr
      .asFunction<aiLogStream Function(int, ffi.Pointer<ffi.Char>)>();

  /// Attach a custom log stream to the libraries' logging system.
  ///
  /// Attaching a log stream can slightly reduce Assimp's overall import
  /// performance. Multiple log-streams can be attached.
  /// @param stream Describes the new log stream.
  /// @note To ensure proper destruction of the logging system, you need to manually
  /// call aiDetachLogStream() on every single log stream you attach.
  /// Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
  void aiAttachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiAttachLogStream(
      stream,
    );
  }

  late final _aiAttachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiLogStream>)>>(
          'aiAttachLogStream');
  late final _aiAttachLogStream = _aiAttachLogStreamPtr
      .asFunction<void Function(ffi.Pointer<aiLogStream>)>();

  /// Enable verbose logging. Verbose logging includes debug-related stuff and
  /// detailed import statistics. This can have severe impact on import performance
  /// and memory consumption. However, it might be useful to find out why a file
  /// didn't read correctly.
  /// @param d AI_TRUE or AI_FALSE, your decision.
  void aiEnableVerboseLogging(
    int d,
  ) {
    return _aiEnableVerboseLogging(
      d,
    );
  }

  late final _aiEnableVerboseLoggingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(aiBool)>>(
          'aiEnableVerboseLogging');
  late final _aiEnableVerboseLogging =
      _aiEnableVerboseLoggingPtr.asFunction<void Function(int)>();

  /// Detach a custom log stream from the libraries' logging system.
  ///
  /// This is the counterpart of #aiAttachLogStream. If you attached a stream,
  /// don't forget to detach it again.
  /// @param stream The log stream to be detached.
  /// @return AI_SUCCESS if the log stream has been detached successfully.
  /// @see aiDetachAllLogStreams
  aiReturn aiDetachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return aiReturn.fromValue(_aiDetachLogStream(
      stream,
    ));
  }

  late final _aiDetachLogStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<aiLogStream>)>>(
          'aiDetachLogStream');
  late final _aiDetachLogStream = _aiDetachLogStreamPtr
      .asFunction<int Function(ffi.Pointer<aiLogStream>)>();

  /// Detach all active log streams from the libraries' logging system.
  /// This ensures that the logging system is terminated properly and all
  /// resources allocated by it are actually freed. If you attached a stream,
  /// don't forget to detach it again.
  /// @see aiAttachLogStream
  /// @see aiDetachLogStream
  void aiDetachAllLogStreams() {
    return _aiDetachAllLogStreams();
  }

  late final _aiDetachAllLogStreamsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('aiDetachAllLogStreams');
  late final _aiDetachAllLogStreams =
      _aiDetachAllLogStreamsPtr.asFunction<void Function()>();

  /// Releases all resources associated with the given import process.
  ///
  /// Call this function after you're done with the imported data.
  /// @param pScene The imported data to release. NULL is a valid value.
  void aiReleaseImport(
    ffi.Pointer<aiScene> pScene,
  ) {
    return _aiReleaseImport(
      pScene,
    );
  }

  late final _aiReleaseImportPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiScene>)>>(
          'aiReleaseImport');
  late final _aiReleaseImport =
      _aiReleaseImportPtr.asFunction<void Function(ffi.Pointer<aiScene>)>();

  /// Returns the error text of the last failed import process.
  ///
  /// @return A textual description of the error that occurred at the last
  /// import process. NULL if there was no error. There can't be an error if you
  /// got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
  ffi.Pointer<ffi.Char> aiGetErrorString() {
    return _aiGetErrorString();
  }

  late final _aiGetErrorStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetErrorString');
  late final _aiGetErrorString =
      _aiGetErrorStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Returns whether a given file extension is supported by ASSIMP
  ///
  /// @param szExtension Extension for which the function queries support for.
  /// Must include a leading dot '.'. Example: ".3ds", ".md3"
  /// @return AI_TRUE if the file extension is supported.
  int aiIsExtensionSupported(
    ffi.Pointer<ffi.Char> szExtension,
  ) {
    return _aiIsExtensionSupported(
      szExtension,
    );
  }

  late final _aiIsExtensionSupportedPtr =
      _lookup<ffi.NativeFunction<aiBool Function(ffi.Pointer<ffi.Char>)>>(
          'aiIsExtensionSupported');
  late final _aiIsExtensionSupported = _aiIsExtensionSupportedPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get a list of all file extensions supported by ASSIMP.
  ///
  /// If a file extension is contained in the list this does, of course, not
  /// mean that ASSIMP is able to load all files with this extension.
  /// @param szOut String to receive the extension list.
  /// Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
  void aiGetExtensionList(
    ffi.Pointer<aiString> szOut,
  ) {
    return _aiGetExtensionList(
      szOut,
    );
  }

  late final _aiGetExtensionListPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiString>)>>(
          'aiGetExtensionList');
  late final _aiGetExtensionList =
      _aiGetExtensionListPtr.asFunction<void Function(ffi.Pointer<aiString>)>();

  /// Get the approximated storage required by an imported asset
  /// @param pIn Input asset.
  /// @param in Data structure to be filled.
  void aiGetMemoryRequirements(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<aiMemoryInfo> in$,
  ) {
    return _aiGetMemoryRequirements(
      pIn,
      in$,
    );
  }

  late final _aiGetMemoryRequirementsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiScene>,
              ffi.Pointer<aiMemoryInfo>)>>('aiGetMemoryRequirements');
  late final _aiGetMemoryRequirements = _aiGetMemoryRequirementsPtr.asFunction<
      void Function(ffi.Pointer<aiScene>, ffi.Pointer<aiMemoryInfo>)>();

  /// Returns an embedded texture, or nullptr.
  /// @param pIn Input asset.
  /// @param filename Texture path extracted from aiGetMaterialString.
  ffi.Pointer<aiTexture> aiGetEmbeddedTexture(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _aiGetEmbeddedTexture(
      pIn,
      filename,
    );
  }

  late final _aiGetEmbeddedTexturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<aiTexture> Function(ffi.Pointer<aiScene>,
              ffi.Pointer<ffi.Char>)>>('aiGetEmbeddedTexture');
  late final _aiGetEmbeddedTexture = _aiGetEmbeddedTexturePtr.asFunction<
      ffi.Pointer<aiTexture> Function(
          ffi.Pointer<aiScene>, ffi.Pointer<ffi.Char>)>();

  /// Create an empty property store. Property stores are used to collect import
  /// settings.
  /// @return New property store. Property stores need to be manually destroyed using
  /// the #aiReleasePropertyStore API function.
  ffi.Pointer<aiPropertyStore> aiCreatePropertyStore() {
    return _aiCreatePropertyStore();
  }

  late final _aiCreatePropertyStorePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<aiPropertyStore> Function()>>(
          'aiCreatePropertyStore');
  late final _aiCreatePropertyStore = _aiCreatePropertyStorePtr
      .asFunction<ffi.Pointer<aiPropertyStore> Function()>();

  /// Delete a property store.
  /// @param p Property store to be deleted.
  void aiReleasePropertyStore(
    ffi.Pointer<aiPropertyStore> p,
  ) {
    return _aiReleasePropertyStore(
      p,
    );
  }

  late final _aiReleasePropertyStorePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiPropertyStore>)>>(
      'aiReleasePropertyStore');
  late final _aiReleasePropertyStore = _aiReleasePropertyStorePtr
      .asFunction<void Function(ffi.Pointer<aiPropertyStore>)>();

  /// Set an integer property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyInteger(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    int value,
  ) {
    return _aiSetImportPropertyInteger(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyIntegerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('aiSetImportPropertyInteger');
  late final _aiSetImportPropertyInteger =
      _aiSetImportPropertyIntegerPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, int)>();

  /// Set a floating-point property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyFloat(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    double value,
  ) {
    return _aiSetImportPropertyFloat(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyFloatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ai_real)>>('aiSetImportPropertyFloat');
  late final _aiSetImportPropertyFloat =
      _aiSetImportPropertyFloatPtr.asFunction<
          void Function(
              ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>, double)>();

  /// Set a string property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param st New value for the property
  void aiSetImportPropertyString(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiString> st,
  ) {
    return _aiSetImportPropertyString(
      store,
      szName,
      st,
    );
  }

  late final _aiSetImportPropertyStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>>('aiSetImportPropertyString');
  late final _aiSetImportPropertyString =
      _aiSetImportPropertyStringPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiString>)>();

  /// Set a matrix property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param mat New value for the property
  void aiSetImportPropertyMatrix(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Char> szName,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiSetImportPropertyMatrix(
      store,
      szName,
      mat,
    );
  }

  late final _aiSetImportPropertyMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>>('aiSetImportPropertyMatrix');
  late final _aiSetImportPropertyMatrix =
      _aiSetImportPropertyMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiPropertyStore>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a quaternion from a 3x3 rotation matrix.
  /// @param quat Receives the output quaternion.
  /// @param mat Matrix to 'quaternionize'.
  /// @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
  void aiCreateQuaternionFromMatrix(
    ffi.Pointer<aiQuaternion> quat,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiCreateQuaternionFromMatrix(
      quat,
      mat,
    );
  }

  late final _aiCreateQuaternionFromMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiMatrix3x3>)>>('aiCreateQuaternionFromMatrix');
  late final _aiCreateQuaternionFromMatrix =
      _aiCreateQuaternionFromMatrixPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiMatrix3x3>)>();

  /// Decompose a transformation matrix into its rotational, translational and
  /// scaling components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the scaling component
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  /// @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
  void aiDecomposeMatrix(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiDecomposeMatrix(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiDecomposeMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiDecomposeMatrix');
  late final _aiDecomposeMatrix = _aiDecomposeMatrixPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Transpose a 4x4 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransposeMatrix4(
      mat,
    );
  }

  late final _aiTransposeMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiTransposeMatrix4');
  late final _aiTransposeMatrix4 = _aiTransposeMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Transpose a 3x3 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransposeMatrix3(
      mat,
    );
  }

  late final _aiTransposeMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiTransposeMatrix3');
  late final _aiTransposeMatrix3 = _aiTransposeMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 3x3 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix3(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransformVecByMatrix3(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix3x3>)>>('aiTransformVecByMatrix3');
  late final _aiTransformVecByMatrix3 = _aiTransformVecByMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix3x3>)>();

  /// Transform a vector by a 4x4 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix4(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransformVecByMatrix4(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiMatrix4x4>)>>('aiTransformVecByMatrix4');
  late final _aiTransformVecByMatrix4 = _aiTransformVecByMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 4x4 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix4(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMultiplyMatrix4(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMultiplyMatrix4');
  late final _aiMultiplyMatrix4 = _aiMultiplyMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Multiply two 3x3 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix3(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix3x3> src,
  ) {
    return _aiMultiplyMatrix3(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMultiplyMatrix3');
  late final _aiMultiplyMatrix3 = _aiMultiplyMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiIdentityMatrix3(
      mat,
    );
  }

  late final _aiIdentityMatrix3Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiIdentityMatrix3');
  late final _aiIdentityMatrix3 = _aiIdentityMatrix3Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 4x4 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiIdentityMatrix4(
      mat,
    );
  }

  late final _aiIdentityMatrix4Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiIdentityMatrix4');
  late final _aiIdentityMatrix4 = _aiIdentityMatrix4Ptr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns the number of import file formats available in the current Assimp build.
  /// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
  int aiGetImportFormatCount() {
    return _aiGetImportFormatCount();
  }

  late final _aiGetImportFormatCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          'aiGetImportFormatCount');
  late final _aiGetImportFormatCount =
      _aiGetImportFormatCountPtr.asFunction<int Function()>();

  /// Returns a description of the nth import file format. Use #aiGetImportFormatCount()
  /// to learn how many import formats are supported.
  /// @param pIndex Index of the import format to retrieve information for. Valid range is
  /// 0 to #aiGetImportFormatCount()
  /// @return A description of that specific import format. NULL if pIndex is out of range.
  ffi.Pointer<aiImporterDesc> aiGetImportFormatDescription(
    int pIndex,
  ) {
    return _aiGetImportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetImportFormatDescriptionPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<aiImporterDesc> Function(ffi.Size)>>(
      'aiGetImportFormatDescription');
  late final _aiGetImportFormatDescription = _aiGetImportFormatDescriptionPtr
      .asFunction<ffi.Pointer<aiImporterDesc> Function(int)>();

  /// Check if 2D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqual(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2AreEqual(
      a,
      b,
    );
  }

  late final _aiVector2AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2AreEqual');
  late final _aiVector2AreEqual = _aiVector2AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Check if 2D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector2AreEqualEpsilon(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
    double epsilon,
  ) {
    return _aiVector2AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector2AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>,
              ffi.Float)>>('aiVector2AreEqualEpsilon');
  late final _aiVector2AreEqualEpsilon =
      _aiVector2AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>, double)>();

  /// Add 2D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector2Add(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Add(
      dst,
      src,
    );
  }

  late final _aiVector2AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Add');
  late final _aiVector2Add = _aiVector2AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Subtract 2D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector2Subtract(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> src,
  ) {
    return _aiVector2Subtract(
      dst,
      src,
    );
  }

  late final _aiVector2SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2Subtract');
  late final _aiVector2Subtract = _aiVector2SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Multiply a 2D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector2Scale(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2Scale(
      dst,
      s,
    );
  }

  late final _aiVector2ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2Scale');
  late final _aiVector2Scale = _aiVector2ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Multiply each component of a 2D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector2SymMul(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> other,
  ) {
    return _aiVector2SymMul(
      dst,
      other,
    );
  }

  late final _aiVector2SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2SymMul');
  late final _aiVector2SymMul = _aiVector2SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Divide a 2D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector2DivideByScalar(
    ffi.Pointer<aiVector2D> dst,
    double s,
  ) {
    return _aiVector2DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector2DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector2D>, ffi.Float)>>('aiVector2DivideByScalar');
  late final _aiVector2DivideByScalar = _aiVector2DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>, double)>();

  /// Divide each component of a 2D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector2DivideByVector(
    ffi.Pointer<aiVector2D> dst,
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector2DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DivideByVector');
  late final _aiVector2DivideByVector = _aiVector2DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Get the length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2Length(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Length(
      v,
    );
  }

  late final _aiVector2LengthPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Length');
  late final _aiVector2Length = _aiVector2LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Get the squared length of a 2D vector.
  /// @return v Vector to evaluate
  double aiVector2SquareLength(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2SquareLength(
      v,
    );
  }

  late final _aiVector2SquareLengthPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2SquareLength');
  late final _aiVector2SquareLength = _aiVector2SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector2D>)>();

  /// Negate a 2D vector.
  /// @param dst Vector to be negated
  void aiVector2Negate(
    ffi.Pointer<aiVector2D> dst,
  ) {
    return _aiVector2Negate(
      dst,
    );
  }

  late final _aiVector2NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Negate');
  late final _aiVector2Negate =
      _aiVector2NegatePtr.asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Get the dot product of 2D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector2DotProduct(
    ffi.Pointer<aiVector2D> a,
    ffi.Pointer<aiVector2D> b,
  ) {
    return _aiVector2DotProduct(
      a,
      b,
    );
  }

  late final _aiVector2DotProductPtr = _lookup<
      ffi.NativeFunction<
          ai_real Function(ffi.Pointer<aiVector2D>,
              ffi.Pointer<aiVector2D>)>>('aiVector2DotProduct');
  late final _aiVector2DotProduct = _aiVector2DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector2D>, ffi.Pointer<aiVector2D>)>();

  /// Normalize a 2D vector.
  /// @param v Vector to normalize
  void aiVector2Normalize(
    ffi.Pointer<aiVector2D> v,
  ) {
    return _aiVector2Normalize(
      v,
    );
  }

  late final _aiVector2NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector2D>)>>(
          'aiVector2Normalize');
  late final _aiVector2Normalize = _aiVector2NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector2D>)>();

  /// Check if 3D vectors are equal.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqual(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3AreEqual(
      a,
      b,
    );
  }

  late final _aiVector3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3AreEqual');
  late final _aiVector3AreEqual = _aiVector3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Check if 3D vectors are equal using epsilon.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if the vectors are equal
  /// @return 0 if the vectors are not equal
  int aiVector3AreEqualEpsilon(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
    double epsilon,
  ) {
    return _aiVector3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiVector3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiVector3AreEqualEpsilon');
  late final _aiVector3AreEqualEpsilon =
      _aiVector3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>, double)>();

  /// Check if vector \p a is less than vector \p b.
  /// @param a First vector to compare
  /// @param b Second vector to compare
  /// @param epsilon Epsilon
  /// @return 1 if \p a is less than \p b
  /// @return 0 if \p a is equal or greater than \p b
  int aiVector3LessThan(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3LessThan(
      a,
      b,
    );
  }

  late final _aiVector3LessThanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3LessThan');
  late final _aiVector3LessThan = _aiVector3LessThanPtr.asFunction<
      int Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Add 3D vectors.
  /// @param dst First addend, receives result.
  /// @param src Vector to be added to 'dst'.
  void aiVector3Add(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Add(
      dst,
      src,
    );
  }

  late final _aiVector3AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Add');
  late final _aiVector3Add = _aiVector3AddPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Subtract 3D vectors.
  /// @param dst Minuend, receives result.
  /// @param src Vector to be subtracted from 'dst'.
  void aiVector3Subtract(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> src,
  ) {
    return _aiVector3Subtract(
      dst,
      src,
    );
  }

  late final _aiVector3SubtractPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3Subtract');
  late final _aiVector3Subtract = _aiVector3SubtractPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Multiply a 3D vector by a scalar.
  /// @param dst Vector to be scaled by \p s
  /// @param s Scale factor
  void aiVector3Scale(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3Scale(
      dst,
      s,
    );
  }

  late final _aiVector3ScalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3Scale');
  late final _aiVector3Scale = _aiVector3ScalePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Multiply each component of a 3D vector with
  /// the components of another vector.
  /// @param dst First vector, receives result
  /// @param other Second vector
  void aiVector3SymMul(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> other,
  ) {
    return _aiVector3SymMul(
      dst,
      other,
    );
  }

  late final _aiVector3SymMulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3SymMul');
  late final _aiVector3SymMul = _aiVector3SymMulPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Divide a 3D vector by a scalar.
  /// @param dst Vector to be divided by \p s
  /// @param s Scalar divisor
  void aiVector3DivideByScalar(
    ffi.Pointer<aiVector3D> dst,
    double s,
  ) {
    return _aiVector3DivideByScalar(
      dst,
      s,
    );
  }

  late final _aiVector3DivideByScalarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiVector3D>, ffi.Float)>>('aiVector3DivideByScalar');
  late final _aiVector3DivideByScalar = _aiVector3DivideByScalarPtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>, double)>();

  /// Divide each component of a 3D vector by
  /// the components of another vector.
  /// @param dst Vector as the dividend
  /// @param v Vector as the divisor
  void aiVector3DivideByVector(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3DivideByVector(
      dst,
      v,
    );
  }

  late final _aiVector3DivideByVectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DivideByVector');
  late final _aiVector3DivideByVector = _aiVector3DivideByVectorPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get the length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3Length(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Length(
      v,
    );
  }

  late final _aiVector3LengthPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Length');
  late final _aiVector3Length = _aiVector3LengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Get the squared length of a 3D vector.
  /// @return v Vector to evaluate
  double aiVector3SquareLength(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3SquareLength(
      v,
    );
  }

  late final _aiVector3SquareLengthPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3SquareLength');
  late final _aiVector3SquareLength = _aiVector3SquareLengthPtr
      .asFunction<double Function(ffi.Pointer<aiVector3D>)>();

  /// Negate a 3D vector.
  /// @param dst Vector to be negated
  void aiVector3Negate(
    ffi.Pointer<aiVector3D> dst,
  ) {
    return _aiVector3Negate(
      dst,
    );
  }

  late final _aiVector3NegatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Negate');
  late final _aiVector3Negate =
      _aiVector3NegatePtr.asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Get the dot product of 3D vectors.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  double aiVector3DotProduct(
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3DotProduct(
      a,
      b,
    );
  }

  late final _aiVector3DotProductPtr = _lookup<
      ffi.NativeFunction<
          ai_real Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3DotProduct');
  late final _aiVector3DotProduct = _aiVector3DotProductPtr.asFunction<
      double Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Get cross product of 3D vectors.
  /// @param dst Vector to receive the result.
  /// @param a First vector
  /// @param b Second vector
  /// @return The dot product of vectors
  void aiVector3CrossProduct(
    ffi.Pointer<aiVector3D> dst,
    ffi.Pointer<aiVector3D> a,
    ffi.Pointer<aiVector3D> b,
  ) {
    return _aiVector3CrossProduct(
      dst,
      a,
      b,
    );
  }

  late final _aiVector3CrossProductPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiVector3CrossProduct');
  late final _aiVector3CrossProduct = _aiVector3CrossProductPtr.asFunction<
      void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3Normalize(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3Normalize(
      v,
    );
  }

  late final _aiVector3NormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3Normalize');
  late final _aiVector3Normalize = _aiVector3NormalizePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Check for division by zero and normalize a 3D vector.
  /// @param v Vector to normalize
  void aiVector3NormalizeSafe(
    ffi.Pointer<aiVector3D> v,
  ) {
    return _aiVector3NormalizeSafe(
      v,
    );
  }

  late final _aiVector3NormalizeSafePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiVector3D>)>>(
          'aiVector3NormalizeSafe');
  late final _aiVector3NormalizeSafe = _aiVector3NormalizeSafePtr
      .asFunction<void Function(ffi.Pointer<aiVector3D>)>();

  /// Rotate a 3D vector by a quaternion.
  /// @param v The vector to rotate by \p q
  /// @param q Quaternion to use to rotate \p v
  void aiVector3RotateByQuaternion(
    ffi.Pointer<aiVector3D> v,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiVector3RotateByQuaternion(
      v,
      q,
    );
  }

  late final _aiVector3RotateByQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>)>>('aiVector3RotateByQuaternion');
  late final _aiVector3RotateByQuaternion =
      _aiVector3RotateByQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiVector3D>, ffi.Pointer<aiQuaternion>)>();

  /// Construct a 3x3 matrix from a 4x4 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 4x4 matrix to use
  void aiMatrix3FromMatrix4(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix3FromMatrix4(
      dst,
      mat,
    );
  }

  late final _aiMatrix3FromMatrix4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix3FromMatrix4');
  late final _aiMatrix3FromMatrix4 = _aiMatrix3FromMatrix4Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix4x4>)>();

  /// Construct a 3x3 matrix from a quaternion.
  /// @param mat Receives the output matrix
  /// @param q The quaternion matrix to use
  void aiMatrix3FromQuaternion(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiMatrix3FromQuaternion(
      mat,
      q,
    );
  }

  late final _aiMatrix3FromQuaternionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiQuaternion>)>>('aiMatrix3FromQuaternion');
  late final _aiMatrix3FromQuaternion = _aiMatrix3FromQuaternionPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiQuaternion>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqual(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
  ) {
    return _aiMatrix3AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix3AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix3AreEqual');
  late final _aiMatrix3AreEqual = _aiMatrix3AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>)>();

  /// Check if 3x3 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix3AreEqualEpsilon(
    ffi.Pointer<aiMatrix3x3> a,
    ffi.Pointer<aiMatrix3x3> b,
    double epsilon,
  ) {
    return _aiMatrix3AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix3AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>,
              ffi.Float)>>('aiMatrix3AreEqualEpsilon');
  late final _aiMatrix3AreEqualEpsilon =
      _aiMatrix3AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiMatrix3x3>, double)>();

  /// Invert a 3x3 matrix.
  /// @param mat Matrix to invert
  void aiMatrix3Inverse(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Inverse(
      mat,
    );
  }

  late final _aiMatrix3InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Inverse');
  late final _aiMatrix3Inverse = _aiMatrix3InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get the determinant of a 3x3 matrix.
  /// @param mat Matrix to get the determinant from
  double aiMatrix3Determinant(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix3Determinant(
      mat,
    );
  }

  late final _aiMatrix3DeterminantPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiMatrix3x3>)>>(
          'aiMatrix3Determinant');
  late final _aiMatrix3Determinant = _aiMatrix3DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix3x3>)>();

  /// Get a 3x3 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix3RotationZ(
    ffi.Pointer<aiMatrix3x3> mat,
    double angle,
  ) {
    return _aiMatrix3RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix3RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Float)>>('aiMatrix3RotationZ');
  late final _aiMatrix3RotationZ = _aiMatrix3RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix3x3>, double)>();

  /// Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix3FromRotationAroundAxis(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix3FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix3FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix3FromRotationAroundAxis');
  late final _aiMatrix3FromRotationAroundAxis =
      _aiMatrix3FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 3x3 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix3Translation(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector2D> translation,
  ) {
    return _aiMatrix3Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix3TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>,
              ffi.Pointer<aiVector2D>)>>('aiMatrix3Translation');
  late final _aiMatrix3Translation = _aiMatrix3TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector2D>)>();

  /// Create a 3x3 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix3FromTo(
    ffi.Pointer<aiMatrix3x3> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix3FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix3FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix3FromTo');
  late final _aiMatrix3FromTo = _aiMatrix3FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix3x3>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Construct a 4x4 matrix from a 3x3 matrix.
  /// @param dst Receives the output matrix
  /// @param mat The 3x3 matrix to use
  void aiMatrix4FromMatrix3(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiMatrix4FromMatrix3(
      dst,
      mat,
    );
  }

  late final _aiMatrix4FromMatrix3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix3x3>)>>('aiMatrix4FromMatrix3');
  late final _aiMatrix4FromMatrix3 = _aiMatrix4FromMatrix3Ptr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix3x3>)>();

  /// Construct a 4x4 matrix from scaling, rotation and position.
  /// @param mat Receives the output matrix.
  /// @param scaling The scaling for the x,y,z axes
  /// @param rotation The rotation as a hamilton quaternion
  /// @param position The position for the x,y,z axes
  void aiMatrix4FromScalingQuaternionPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4FromScalingQuaternionPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4FromScalingQuaternionPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiQuaternion>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4FromScalingQuaternionPosition');
  late final _aiMatrix4FromScalingQuaternionPosition =
      _aiMatrix4FromScalingQuaternionPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Add 4x4 matrices.
  /// @param dst First addend, receives result.
  /// @param src Matrix to be added to 'dst'.
  void aiMatrix4Add(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMatrix4Add(
      dst,
      src,
    );
  }

  late final _aiMatrix4AddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4Add');
  late final _aiMatrix4Add = _aiMatrix4AddPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqual(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
  ) {
    return _aiMatrix4AreEqual(
      a,
      b,
    );
  }

  late final _aiMatrix4AreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiMatrix4x4>)>>('aiMatrix4AreEqual');
  late final _aiMatrix4AreEqual = _aiMatrix4AreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>)>();

  /// Check if 4x4 matrices are equal.
  /// @param a First matrix to compare
  /// @param b Second matrix to compare
  /// @param epsilon Epsilon
  /// @return 1 if the matrices are equal
  /// @return 0 if the matrices are not equal
  int aiMatrix4AreEqualEpsilon(
    ffi.Pointer<aiMatrix4x4> a,
    ffi.Pointer<aiMatrix4x4> b,
    double epsilon,
  ) {
    return _aiMatrix4AreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiMatrix4AreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>,
              ffi.Float)>>('aiMatrix4AreEqualEpsilon');
  late final _aiMatrix4AreEqualEpsilon =
      _aiMatrix4AreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiMatrix4x4>, double)>();

  /// Invert a 4x4 matrix.
  /// @param result Matrix to invert
  void aiMatrix4Inverse(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Inverse(
      mat,
    );
  }

  late final _aiMatrix4InversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Inverse');
  late final _aiMatrix4Inverse = _aiMatrix4InversePtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Get the determinant of a 4x4 matrix.
  /// @param mat Matrix to get the determinant from
  /// @return The determinant of the matrix
  double aiMatrix4Determinant(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4Determinant(
      mat,
    );
  }

  late final _aiMatrix4DeterminantPtr =
      _lookup<ffi.NativeFunction<ai_real Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4Determinant');
  late final _aiMatrix4Determinant = _aiMatrix4DeterminantPtr
      .asFunction<double Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Returns true of the matrix is the identity matrix.
  /// @param mat Matrix to get the determinant from
  /// @return 1 if \p mat is an identity matrix.
  /// @return 0 if \p mat is not an identity matrix.
  int aiMatrix4IsIdentity(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiMatrix4IsIdentity(
      mat,
    );
  }

  late final _aiMatrix4IsIdentityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<aiMatrix4x4>)>>(
          'aiMatrix4IsIdentity');
  late final _aiMatrix4IsIdentity = _aiMatrix4IsIdentityPtr
      .asFunction<int Function(ffi.Pointer<aiMatrix4x4>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational as euler angles, and translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the output scaling for the x,y,z axes
  /// @param rotation Receives the output rotation as a Euler angles
  /// @param position Receives the output position for the x,y,z axes
  void aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingEulerAnglesPosition');
  late final _aiMatrix4DecomposeIntoScalingEulerAnglesPosition =
      _aiMatrix4DecomposeIntoScalingEulerAnglesPositionPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>, ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its scaling,
  /// rotational split into an axis and rotational angle,
  /// and it's translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param axis Receives the output rotation axis
  /// @param angle Receives the output rotation angle
  /// @param position Receives the output position for the x,y,z axes.
  void aiMatrix4DecomposeIntoScalingAxisAnglePosition(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiVector3D> axis,
    ffi.Pointer<ai_real> angle,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeIntoScalingAxisAnglePosition(
      mat,
      scaling,
      axis,
      angle,
      position,
    );
  }

  late final _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiMatrix4x4>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<aiVector3D>,
                  ffi.Pointer<ai_real>,
                  ffi.Pointer<aiVector3D>)>>(
      'aiMatrix4DecomposeIntoScalingAxisAnglePosition');
  late final _aiMatrix4DecomposeIntoScalingAxisAnglePosition =
      _aiMatrix4DecomposeIntoScalingAxisAnglePositionPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>,
              ffi.Pointer<ai_real>,
              ffi.Pointer<aiVector3D>)>();

  /// Decompose a transformation matrix into its rotational and
  /// translational components.
  ///
  /// @param mat Matrix to decompose
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  void aiMatrix4DecomposeNoScaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiMatrix4DecomposeNoScaling(
      mat,
      rotation,
      position,
    );
  }

  late final _aiMatrix4DecomposeNoScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4DecomposeNoScaling');
  late final _aiMatrix4DecomposeNoScaling =
      _aiMatrix4DecomposeNoScalingPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiVector3D>)>();

  /// Creates a 4x4 matrix from a set of euler angles.
  /// @param mat Receives the output matrix
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiMatrix4FromEulerAngles(
    ffi.Pointer<aiMatrix4x4> mat,
    double x,
    double y,
    double z,
  ) {
    return _aiMatrix4FromEulerAngles(
      mat,
      x,
      y,
      z,
    );
  }

  late final _aiMatrix4FromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiMatrix4FromEulerAngles');
  late final _aiMatrix4FromEulerAngles =
      _aiMatrix4FromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiMatrix4x4>, double, double, double)>();

  /// Get a 4x4 rotation matrix around the X axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationX(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationX(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationXPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationX');
  late final _aiMatrix4RotationX = _aiMatrix4RotationXPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Y axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationY(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationY(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationYPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationY');
  late final _aiMatrix4RotationY = _aiMatrix4RotationYPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Get a 4x4 rotation matrix around the Z axis.
  /// @param mat Receives the output matrix
  /// @param angle Rotation angle, in radians
  void aiMatrix4RotationZ(
    ffi.Pointer<aiMatrix4x4> mat,
    double angle,
  ) {
    return _aiMatrix4RotationZ(
      mat,
      angle,
    );
  }

  late final _aiMatrix4RotationZPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Float)>>('aiMatrix4RotationZ');
  late final _aiMatrix4RotationZ = _aiMatrix4RotationZPtr
      .asFunction<void Function(ffi.Pointer<aiMatrix4x4>, double)>();

  /// Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.
  /// @param mat Receives the output matrix
  /// @param axis Rotation axis, should be a normalized vector
  /// @param angle Rotation angle, in radians
  void aiMatrix4FromRotationAroundAxis(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiMatrix4FromRotationAroundAxis(
      mat,
      axis,
      angle,
    );
  }

  late final _aiMatrix4FromRotationAroundAxisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiMatrix4FromRotationAroundAxis');
  late final _aiMatrix4FromRotationAroundAxis =
      _aiMatrix4FromRotationAroundAxisPtr.asFunction<
          void Function(
              ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>, double)>();

  /// Get a 4x4 translation matrix.
  /// @param mat Receives the output matrix
  /// @param translation The translation vector
  void aiMatrix4Translation(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> translation,
  ) {
    return _aiMatrix4Translation(
      mat,
      translation,
    );
  }

  late final _aiMatrix4TranslationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Translation');
  late final _aiMatrix4Translation = _aiMatrix4TranslationPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Get a 4x4 scaling matrix.
  /// @param mat Receives the output matrix
  /// @param scaling The scaling vector
  void aiMatrix4Scaling(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
  ) {
    return _aiMatrix4Scaling(
      mat,
      scaling,
    );
  }

  late final _aiMatrix4ScalingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4Scaling');
  late final _aiMatrix4Scaling = _aiMatrix4ScalingPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>)>();

  /// Create a 4x4 matrix that rotates one vector to another vector.
  /// @param mat Receives the output matrix
  /// @param from Vector to rotate from
  /// @param to Vector to rotate to
  void aiMatrix4FromTo(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> from,
    ffi.Pointer<aiVector3D> to,
  ) {
    return _aiMatrix4FromTo(
      mat,
      from,
      to,
    );
  }

  late final _aiMatrix4FromToPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
              ffi.Pointer<aiVector3D>)>>('aiMatrix4FromTo');
  late final _aiMatrix4FromTo = _aiMatrix4FromToPtr.asFunction<
      void Function(ffi.Pointer<aiMatrix4x4>, ffi.Pointer<aiVector3D>,
          ffi.Pointer<aiVector3D>)>();

  /// Create a Quaternion from euler angles.
  /// @param q Receives the output quaternion
  /// @param x Rotation angle for the x-axis, in radians
  /// @param y Rotation angle for the y-axis, in radians
  /// @param z Rotation angle for the z-axis, in radians
  void aiQuaternionFromEulerAngles(
    ffi.Pointer<aiQuaternion> q,
    double x,
    double y,
    double z,
  ) {
    return _aiQuaternionFromEulerAngles(
      q,
      x,
      y,
      z,
    );
  }

  late final _aiQuaternionFromEulerAnglesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Float, ffi.Float,
              ffi.Float)>>('aiQuaternionFromEulerAngles');
  late final _aiQuaternionFromEulerAngles =
      _aiQuaternionFromEulerAnglesPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, double, double, double)>();

  /// Create a Quaternion from an axis angle pair.
  /// @param q Receives the output quaternion
  /// @param axis The orientation axis
  /// @param angle The rotation angle, in radians
  void aiQuaternionFromAxisAngle(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> axis,
    double angle,
  ) {
    return _aiQuaternionFromAxisAngle(
      q,
      axis,
      angle,
    );
  }

  late final _aiQuaternionFromAxisAnglePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>,
              ffi.Float)>>('aiQuaternionFromAxisAngle');
  late final _aiQuaternionFromAxisAngle =
      _aiQuaternionFromAxisAnglePtr.asFunction<
          void Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>, double)>();

  /// Create a Quaternion from a normalized quaternion stored
  /// in a 3D vector.
  /// @param q Receives the output quaternion
  /// @param normalized The vector that stores the quaternion
  void aiQuaternionFromNormalizedQuaternion(
    ffi.Pointer<aiQuaternion> q,
    ffi.Pointer<aiVector3D> normalized,
  ) {
    return _aiQuaternionFromNormalizedQuaternion(
      q,
      normalized,
    );
  }

  late final _aiQuaternionFromNormalizedQuaternionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>>(
      'aiQuaternionFromNormalizedQuaternion');
  late final _aiQuaternionFromNormalizedQuaternion =
      _aiQuaternionFromNormalizedQuaternionPtr.asFunction<
          void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiVector3D>)>();

  /// Check if quaternions are equal.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqual(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
  ) {
    return _aiQuaternionAreEqual(
      a,
      b,
    );
  }

  late final _aiQuaternionAreEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionAreEqual');
  late final _aiQuaternionAreEqual = _aiQuaternionAreEqualPtr.asFunction<
      int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Check if quaternions are equal using epsilon.
  /// @param a First quaternion to compare
  /// @param b Second quaternion to compare
  /// @param epsilon Epsilon
  /// @return 1 if the quaternions are equal
  /// @return 0 if the quaternions are not equal
  int aiQuaternionAreEqualEpsilon(
    ffi.Pointer<aiQuaternion> a,
    ffi.Pointer<aiQuaternion> b,
    double epsilon,
  ) {
    return _aiQuaternionAreEqualEpsilon(
      a,
      b,
      epsilon,
    );
  }

  late final _aiQuaternionAreEqualEpsilonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionAreEqualEpsilon');
  late final _aiQuaternionAreEqualEpsilon =
      _aiQuaternionAreEqualEpsilonPtr.asFunction<
          int Function(
              ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>, double)>();

  /// Normalize a quaternion.
  /// @param q Quaternion to normalize
  void aiQuaternionNormalize(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionNormalize(
      q,
    );
  }

  late final _aiQuaternionNormalizePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionNormalize');
  late final _aiQuaternionNormalize = _aiQuaternionNormalizePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Compute quaternion conjugate.
  /// @param q Quaternion to compute conjugate,
  /// receives the output quaternion
  void aiQuaternionConjugate(
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionConjugate(
      q,
    );
  }

  late final _aiQuaternionConjugatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<aiQuaternion>)>>(
          'aiQuaternionConjugate');
  late final _aiQuaternionConjugate = _aiQuaternionConjugatePtr
      .asFunction<void Function(ffi.Pointer<aiQuaternion>)>();

  /// Multiply quaternions.
  /// @param dst First quaternion, receives the output quaternion
  /// @param q Second quaternion
  void aiQuaternionMultiply(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> q,
  ) {
    return _aiQuaternionMultiply(
      dst,
      q,
    );
  }

  late final _aiQuaternionMultiplyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>)>>('aiQuaternionMultiply');
  late final _aiQuaternionMultiply = _aiQuaternionMultiplyPtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>)>();

  /// Performs a spherical interpolation between two quaternions.
  /// @param dst Receives the quaternion resulting from the interpolation.
  /// @param start Quaternion when factor == 0
  /// @param end Quaternion when factor == 1
  /// @param factor Interpolation factor between 0 and 1
  void aiQuaternionInterpolate(
    ffi.Pointer<aiQuaternion> dst,
    ffi.Pointer<aiQuaternion> start,
    ffi.Pointer<aiQuaternion> end,
    double factor,
  ) {
    return _aiQuaternionInterpolate(
      dst,
      start,
      end,
      factor,
    );
  }

  late final _aiQuaternionInterpolatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Pointer<aiQuaternion>,
              ffi.Float)>>('aiQuaternionInterpolate');
  late final _aiQuaternionInterpolate = _aiQuaternionInterpolatePtr.asFunction<
      void Function(ffi.Pointer<aiQuaternion>, ffi.Pointer<aiQuaternion>,
          ffi.Pointer<aiQuaternion>, double)>();

  /// @brief Returns a string with legal copyright and licensing information
  /// about Assimp. The string may include multiple lines.
  /// @return Pointer to static string.
  ffi.Pointer<ffi.Char> aiGetLegalString() {
    return _aiGetLegalString();
  }

  late final _aiGetLegalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetLegalString');
  late final _aiGetLegalString =
      _aiGetLegalStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns the current patch version number of Assimp.
  /// @return Patch version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionPatch() {
    return _aiGetVersionPatch();
  }

  late final _aiGetVersionPatchPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionPatch');
  late final _aiGetVersionPatch =
      _aiGetVersionPatchPtr.asFunction<int Function()>();

  /// @brief Returns the current minor version number of Assimp.
  /// @return Minor version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMinor() {
    return _aiGetVersionMinor();
  }

  late final _aiGetVersionMinorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMinor');
  late final _aiGetVersionMinor =
      _aiGetVersionMinorPtr.asFunction<int Function()>();

  /// @brief Returns the current major version number of Assimp.
  /// @return Major version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMajor() {
    return _aiGetVersionMajor();
  }

  late final _aiGetVersionMajorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionMajor');
  late final _aiGetVersionMajor =
      _aiGetVersionMajorPtr.asFunction<int Function()>();

  /// @brief Returns the repository revision of the Assimp runtime.
  /// @return SVN Repository revision number of the Assimp runtime the
  /// application was linked/built against.
  int aiGetVersionRevision() {
    return _aiGetVersionRevision();
  }

  late final _aiGetVersionRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetVersionRevision');
  late final _aiGetVersionRevision =
      _aiGetVersionRevisionPtr.asFunction<int Function()>();

  /// @brief Returns the branch-name of the Assimp runtime.
  /// @return The current branch name.
  ffi.Pointer<ffi.Char> aiGetBranchName() {
    return _aiGetBranchName();
  }

  late final _aiGetBranchNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'aiGetBranchName');
  late final _aiGetBranchName =
      _aiGetBranchNamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Returns assimp's compile flags
  /// @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.
  int aiGetCompileFlags() {
    return _aiGetCompileFlags();
  }

  late final _aiGetCompileFlagsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'aiGetCompileFlags');
  late final _aiGetCompileFlags =
      _aiGetCompileFlagsPtr.asFunction<int Function()>();
}

typedef va_list = ffi.Pointer<ffi.Char>;
typedef ptrdiff_t = ffi.LongLong;
typedef Dartptrdiff_t = int;
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;
typedef wint_t = ffi.UnsignedShort;
typedef Dartwint_t = int;
typedef wctype_t = ffi.UnsignedShort;
typedef Dartwctype_t = int;
typedef __time32_t = ffi.Long;
typedef Dart__time32_t = int;
typedef __time64_t = ffi.LongLong;
typedef Dart__time64_t = int;

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

typedef mbstate_t = _Mbstatet;
typedef time_t = __time64_t;
typedef rsize_t = ffi.Size;
typedef Dartrsize_t = int;
typedef int_least8_t = ffi.SignedChar;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Short;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.LongLong;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.UnsignedChar;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.UnsignedShort;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.UnsignedInt;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.UnsignedLongLong;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.LongLong;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedInt;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedInt;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLongLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.LongLong;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLongLong;
typedef Dartuintmax_t = int;
typedef _ino_t = ffi.UnsignedShort;
typedef Dart_ino_t = int;
typedef ino_t = _ino_t;
typedef _dev_t = ffi.UnsignedInt;
typedef Dart_dev_t = int;
typedef dev_t = _dev_t;
typedef _off_t = ffi.Long;
typedef Dart_off_t = int;
typedef off_t = _off_t;

/// @brief Enumerates components of the aiScene and aiMesh data structures
/// that can be excluded from the import using the #aiProcess_RemoveComponent step.
///
/// See the documentation to #aiProcess_RemoveComponent for more details.
enum aiComponent {
  aiComponent_NORMALS(2),
  aiComponent_TANGENTS_AND_BITANGENTS(4),

  /// ALL color sets
  /// Use aiComponent_COLORn(N) to specify the N'th set
  aiComponent_COLORS(8),

  /// ALL texture UV sets
  /// aiComponent_TEXCOORDn(N) to specify the N'th set
  aiComponent_TEXCOORDS(16),

  /// Removes all bone weights from all meshes.
  /// The scenegraph nodes corresponding to the bones are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  aiComponent_BONEWEIGHTS(32),

  /// Removes all node animations (aiScene::mAnimations).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  aiComponent_ANIMATIONS(64),

  /// Removes all embedded textures (aiScene::mTextures)
  aiComponent_TEXTURES(128),

  /// Removes all light sources (aiScene::mLights).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  aiComponent_LIGHTS(256),

  /// Removes all cameras (aiScene::mCameras).
  /// The corresponding scenegraph nodes are NOT removed.
  /// use the #aiProcess_OptimizeGraph step to do this
  aiComponent_CAMERAS(512),

  /// Removes all meshes (aiScene::mMeshes).
  aiComponent_MESHES(1024),

  /// Removes all materials. One default material will
  /// be generated, so aiScene::mNumMaterials will be 1.
  aiComponent_MATERIALS(2048),
  _aiComponent_Force32Bit(-1610612737);

  final int value;
  const aiComponent(this.value);

  static aiComponent fromValue(int value) => switch (value) {
        2 => aiComponent_NORMALS,
        4 => aiComponent_TANGENTS_AND_BITANGENTS,
        8 => aiComponent_COLORS,
        16 => aiComponent_TEXCOORDS,
        32 => aiComponent_BONEWEIGHTS,
        64 => aiComponent_ANIMATIONS,
        128 => aiComponent_TEXTURES,
        256 => aiComponent_LIGHTS,
        512 => aiComponent_CAMERAS,
        1024 => aiComponent_MESHES,
        2048 => aiComponent_MATERIALS,
        -1610612737 => _aiComponent_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiComponent: $value'),
      };
}

typedef ai_real = ffi.Float;
typedef Dartai_real = double;
typedef ai_int = ffi.Int;
typedef Dartai_int = int;
typedef ai_uint = ffi.UnsignedInt;
typedef Dartai_uint = int;
typedef float_t = ffi.Float;
typedef Dartfloat_t = double;
typedef double_t = ffi.Double;
typedef Dartdouble_t = double;

final class _double_val extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Double()
  external double _Val;
}

final class _float_val extends ffi.Union {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedShort> _Sh;

  @ffi.Float()
  external double _Val;
}

final class _ldouble_val extends ffi.Opaque {}

final class _float_const extends ffi.Opaque {}

final class aiVector2D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;
}

final class aiVector3D extends ffi.Struct {
  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

final class aiColor4D extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double a;
}

final class aiMatrix3x3 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;
}

final class aiMatrix4x4 extends ffi.Struct {
  @ai_real()
  external double a1;

  @ai_real()
  external double a2;

  @ai_real()
  external double a3;

  @ai_real()
  external double a4;

  @ai_real()
  external double b1;

  @ai_real()
  external double b2;

  @ai_real()
  external double b3;

  @ai_real()
  external double b4;

  @ai_real()
  external double c1;

  @ai_real()
  external double c2;

  @ai_real()
  external double c3;

  @ai_real()
  external double c4;

  @ai_real()
  external double d1;

  @ai_real()
  external double d2;

  @ai_real()
  external double d3;

  @ai_real()
  external double d4;
}

final class aiQuaternion extends ffi.Struct {
  @ai_real()
  external double w;

  @ai_real()
  external double x;

  @ai_real()
  external double y;

  @ai_real()
  external double z;
}

typedef ai_int32 = ffi.Int32;
typedef Dartai_int32 = int;
typedef ai_uint32 = ffi.Uint32;
typedef Dartai_uint32 = int;

/// Represents a plane in a three-dimensional, euclidean space
final class aiPlane extends ffi.Struct {
  /// ! Plane equation
  @ai_real()
  external double a;

  @ai_real()
  external double b;

  @ai_real()
  external double c;

  @ai_real()
  external double d;
}

/// Represents a ray
final class aiRay extends ffi.Struct {
  /// ! Position and direction of the ray
  external aiVector3D pos;

  external aiVector3D dir;
}

/// Represents a color in Red-Green-Blue space.
final class aiColor3D extends ffi.Struct {
  /// ! Red, green and blue color values
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;
}

/// @brief Represents an UTF-8 string, zero byte terminated.
///
/// The character set of an aiString is explicitly defined to be UTF-8. This Unicode
/// transformation was chosen in the belief that most strings in 3d files are limited
/// to ASCII, thus the character set needed to be strictly ASCII compatible.
///
/// Most text file loaders provide proper Unicode input file handling, special unicode
/// characters are correctly transcoded to UTF8 and are kept throughout the libraries'
/// import pipeline.
///
/// For most applications, it will be absolutely sufficient to interpret the
/// aiString as ASCII data and work with it as one would work with a plain char*.
/// Windows users in need of proper support for i.e asian characters can use the
/// MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the
/// UTF-8 strings to their working character set (i.e. MBCS, WideChar).
///
/// We use this representation instead of std::string to be C-compatible. The
/// (binary) length of such a string is limited to AI_MAXLEN characters (including the
/// the terminating zero).
final class aiString extends ffi.Struct {
  /// Binary length of the string excluding the terminal 0. This is NOT the
  /// logical length of strings containing UTF-8 multi-byte sequences! It's
  /// the number of bytes from the beginning of the string to its end.
  @ai_uint32()
  external int length;

  /// String buffer. Size limit is AI_MAXLEN
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> data;
}

/// Standard return type for some library functions.
/// Rarely used, and if, mostly in the C API.
enum aiReturn {
  /// Indicates that a function was successful
  aiReturn_SUCCESS(0),

  /// Indicates that a function failed
  aiReturn_FAILURE(-1),

  /// Indicates that not enough memory was available
  /// to perform the requested operation
  aiReturn_OUTOFMEMORY(-3),

  /// @cond never
  /// Force 32-bit size enum
  _AI_ENFORCE_ENUM_SIZE(2147483647);

  final int value;
  const aiReturn(this.value);

  static aiReturn fromValue(int value) => switch (value) {
        0 => aiReturn_SUCCESS,
        -1 => aiReturn_FAILURE,
        -3 => aiReturn_OUTOFMEMORY,
        2147483647 => _AI_ENFORCE_ENUM_SIZE,
        _ => throw ArgumentError('Unknown value for aiReturn: $value'),
      };
}

/// Seek origins (for the virtual file system API).
/// Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.
enum aiOrigin {
  /// Beginning of the file
  aiOrigin_SET(0),

  /// Current position of the file pointer
  aiOrigin_CUR(1),

  /// End of the file, offsets must be negative
  aiOrigin_END(2),

  /// @cond never
  /// Force 32-bit size enum
  _AI_ORIGIN_ENFORCE_ENUM_SIZE(2147483647);

  final int value;
  const aiOrigin(this.value);

  static aiOrigin fromValue(int value) => switch (value) {
        0 => aiOrigin_SET,
        1 => aiOrigin_CUR,
        2 => aiOrigin_END,
        2147483647 => _AI_ORIGIN_ENFORCE_ENUM_SIZE,
        _ => throw ArgumentError('Unknown value for aiOrigin: $value'),
      };
}

/// @brief Enumerates predefined log streaming destinations.
/// Logging to these streams can be enabled with a single call to
/// #LogStream::createDefaultStream.
enum aiDefaultLogStream {
  /// Stream the log to a file
  aiDefaultLogStream_FILE(1),

  /// Stream the log to std::cout
  aiDefaultLogStream_STDOUT(2),

  /// Stream the log to std::cerr
  aiDefaultLogStream_STDERR(4),

  /// MSVC only: Stream the log the the debugger
  /// (this relies on OutputDebugString from the Win32 SDK)
  aiDefaultLogStream_DEBUGGER(8),

  /// @cond never
  /// Force 32-bit size enum
  _AI_DLS_ENFORCE_ENUM_SIZE(2147483647);

  final int value;
  const aiDefaultLogStream(this.value);

  static aiDefaultLogStream fromValue(int value) => switch (value) {
        1 => aiDefaultLogStream_FILE,
        2 => aiDefaultLogStream_STDOUT,
        4 => aiDefaultLogStream_STDERR,
        8 => aiDefaultLogStream_DEBUGGER,
        2147483647 => _AI_DLS_ENFORCE_ENUM_SIZE,
        _ =>
          throw ArgumentError('Unknown value for aiDefaultLogStream: $value'),
      };
}

/// Stores the memory requirements for different components (e.g. meshes, materials,
/// animations) of an import. All sizes are in bytes.
/// @see Importer::GetMemoryRequirements()
final class aiMemoryInfo extends ffi.Struct {
  /// Storage allocated for texture data
  @ffi.UnsignedInt()
  external int textures;

  /// Storage allocated for material data
  @ffi.UnsignedInt()
  external int materials;

  /// Storage allocated for mesh data
  @ffi.UnsignedInt()
  external int meshes;

  /// Storage allocated for node data
  @ffi.UnsignedInt()
  external int nodes;

  /// Storage allocated for animation data
  @ffi.UnsignedInt()
  external int animations;

  /// Storage allocated for camera data
  @ffi.UnsignedInt()
  external int cameras;

  /// Storage allocated for light data
  @ffi.UnsignedInt()
  external int lights;

  /// Total storage allocated for the full import.
  @ffi.UnsignedInt()
  external int total;
}

/// @brief  Type to store a in-memory data buffer.
final class aiBuffer extends ffi.Struct {
  /// < Begin poiner
  external ffi.Pointer<ffi.Char> data;

  /// < End pointer
  external ffi.Pointer<ffi.Char> end;
}

/// @brief Helper structure to represent a texel in a ARGB8888 format
///
/// Used by aiTexture.
@ffi.Packed(1)
final class aiTexel extends ffi.Struct {
  @ffi.UnsignedChar()
  external int b;

  @ffi.UnsignedChar()
  external int g;

  @ffi.UnsignedChar()
  external int r;

  @ffi.UnsignedChar()
  external int a;
}

/// Helper structure to describe an embedded texture
///
/// Normally textures are contained in external files but some file formats embed
/// them directly in the model file. There are two types of embedded textures:
/// 1. Uncompressed textures. The color data is given in an uncompressed format.
/// 2. Compressed textures stored in a file format like png or jpg. The raw file
/// bytes are given so the application must utilize an image decoder (e.g. DevIL) to
/// get access to the actual color data.
///
/// Embedded textures are referenced from materials using strings like "*0", "*1", etc.
/// as the texture paths (a single asterisk character followed by the
/// zero-based index of the texture in the aiScene::mTextures array).
final class aiTexture extends ffi.Struct {
  /// Width of the texture, in pixels
  ///
  /// If mHeight is zero the texture is compressed in a format
  /// like JPEG. In this case mWidth specifies the size of the
  /// memory area pcData is pointing to, in bytes.
  @ffi.UnsignedInt()
  external int mWidth;

  /// Height of the texture, in pixels
  ///
  /// If this value is zero, pcData points to an compressed texture
  /// in any format (e.g. JPEG).
  @ffi.UnsignedInt()
  external int mHeight;

  /// A hint from the loader to make it easier for applications
  /// to determine the type of embedded textures.
  ///
  /// If mHeight != 0 this member is show how data is packed. Hint will consist of
  /// two parts: channel order and channel bitness (count of the bits for every
  /// color channel). For simple parsing by the viewer it's better to not omit
  /// absent color channel and just use 0 for bitness. For example:
  /// 1. Image contain RGBA and 8 bit per channel, achFormatHint == "rgba8888";
  /// 2. Image contain ARGB and 8 bit per channel, achFormatHint == "argb8888";
  /// 3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == "rgba5650";
  /// 4. One color image with B channel and 1 bit for it, achFormatHint == "rgba0010";
  /// If mHeight == 0 then achFormatHint is set set to '\\0\\0\\0\\0' if the loader has no additional
  /// information about the texture file format used OR the
  /// file extension of the format without a trailing dot. If there
  /// are multiple file extensions for a format, the shortest
  /// extension is chosen (JPEG maps to 'jpg', not to 'jpeg').
  /// E.g. 'dds\\0', 'pcx\\0', 'jpg\\0'.  All characters are lower-case.
  /// The fourth character will always be '\\0'.
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Char> achFormatHint;

  /// Data of the texture.
  ///
  /// Points to an array of mWidth * mHeight aiTexel's.
  /// The format of the texture data shall always be ARGB8888 if the texture-hint of the type is empty.
  /// If the hint is not empty you can interpret the format by looking into this hint.
  /// make the implementation for user of the library as easy
  /// as possible. If mHeight = 0 this is a pointer to a memory
  /// buffer of size mWidth containing the compressed texture
  /// data. Good luck, have fun!
  external ffi.Pointer<aiTexel> pcData;

  /// Texture original filename
  ///
  /// Used to get the texture reference
  external aiString mFilename;
}

/// An axis-aligned bounding box.
final class aiAABB extends ffi.Struct {
  external aiVector3D mMin;

  external aiVector3D mMax;
}

/// @brief A single face in a mesh, referring to multiple vertices.
///
/// If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3
/// it's called 'polygon' (hey, that's just a definition!).
/// <br>
/// aiMesh::mPrimitiveTypes can be queried to quickly examine which types of
/// primitive are actually present in a mesh. The #aiProcess_SortByPType flag
/// executes a special post-processing algorithm which splits meshes with
/// *different* primitive types mixed up (e.g. lines and triangles) in several
/// 'clean' sub-meshes. Furthermore there is a configuration option (
/// #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove
/// specific kinds of primitives from the imported scene, completely and forever.
/// In many cases you'll probably want to set this setting to
/// @code
/// aiPrimitiveType_LINE|aiPrimitiveType_POINT
/// @endcode
/// Together with the #aiProcess_Triangulate flag you can then be sure that
/// #aiFace::mNumIndices is always 3.
/// @note Take a look at the @link data Data Structures page @endlink for
/// more information on the layout and winding order of a face.
final class aiFace extends ffi.Struct {
  /// ! Number of indices defining this face.
  /// ! The maximum value for this member is #AI_MAX_FACE_INDICES.
  @ffi.UnsignedInt()
  external int mNumIndices;

  /// ! Pointer to the indices array. Size of the array is given in numIndices.
  external ffi.Pointer<ffi.UnsignedInt> mIndices;
}

/// @brief A single influence of a bone on a vertex.
final class aiVertexWeight extends ffi.Struct {
  /// ! Index of the vertex which is influenced by the bone.
  @ffi.UnsignedInt()
  external int mVertexId;

  /// ! The strength of the influence in the range (0...1).
  /// ! The influence from all bones at one vertex amounts to 1.
  @ai_real()
  external double mWeight;
}

/// Enum used to distinguish data types
enum aiMetadataType {
  AI_BOOL(0),
  AI_INT32(1),
  AI_UINT64(2),
  AI_FLOAT(3),
  AI_DOUBLE(4),
  AI_AISTRING(5),
  AI_AIVECTOR3D(6),
  AI_AIMETADATA(7),
  AI_INT64(8),
  AI_UINT32(9),
  AI_META_MAX(10),
  FORCE_32BIT(2147483647);

  final int value;
  const aiMetadataType(this.value);

  static aiMetadataType fromValue(int value) => switch (value) {
        0 => AI_BOOL,
        1 => AI_INT32,
        2 => AI_UINT64,
        3 => AI_FLOAT,
        4 => AI_DOUBLE,
        5 => AI_AISTRING,
        6 => AI_AIVECTOR3D,
        7 => AI_AIMETADATA,
        8 => AI_INT64,
        9 => AI_UINT32,
        10 => AI_META_MAX,
        2147483647 => FORCE_32BIT,
        _ => throw ArgumentError('Unknown value for aiMetadataType: $value'),
      };
}

/// Metadata entry
///
/// The type field uniquely identifies the underlying type of the data field
final class aiMetadataEntry extends ffi.Struct {
  @ffi.UnsignedInt()
  external int mTypeAsInt;

  aiMetadataType get mType => aiMetadataType.fromValue(mTypeAsInt);

  external ffi.Pointer<ffi.Void> mData;
}

/// Container for holding metadata.
///
/// Metadata is a key-value store using string keys and values.
final class aiMetadata extends ffi.Struct {
  /// Length of the mKeys and mValues arrays, respectively
  @ffi.UnsignedInt()
  external int mNumProperties;

  /// Arrays of keys, may not be NULL. Entries in this array may not be NULL as well.
  external ffi.Pointer<aiString> mKeys;

  /// Arrays of values, may not be NULL. Entries in this array may be NULL if the
  /// corresponding property key has no assigned value.
  external ffi.Pointer<aiMetadataEntry> mValues;
}

/// A node in the imported hierarchy.
///
/// Each node has name, a parent node (except for the root node),
/// a transformation relative to its parent and possibly several child nodes.
/// Simple file formats don't support hierarchical structures - for these formats
/// the imported scene does consist of only a single root node without children.
final class aiNode extends ffi.Struct {
  /// The name of the node.
  ///
  /// The name might be empty (length of zero) but all nodes which
  /// need to be referenced by either bones or animations are named.
  /// Multiple nodes may have the same name, except for nodes which are referenced
  /// by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
  ///
  /// Cameras and lights reference a specific node by name - if there
  /// are multiple nodes with this name, they are assigned to each of them.
  /// <br>
  /// There are no limitations with regard to the characters contained in
  /// the name string as it is usually taken directly from the source file.
  ///
  /// Implementations should be able to handle tokens such as whitespace, tabs,
  /// line feeds, quotation marks, ampersands etc.
  ///
  /// Sometimes assimp introduces new nodes not present in the source file
  /// into the hierarchy (usually out of necessity because sometimes the
  /// source hierarchy format is simply not compatible). Their names are
  /// surrounded by @verbatim <> @endverbatim e.g.
  /// @verbatim<DummyRootNode> @endverbatim.
  external aiString mName;

  /// The transformation relative to the node's parent.
  external aiMatrix4x4 mTransformation;

  /// Parent node. nullptr if this node is the root node.
  external ffi.Pointer<aiNode> mParent;

  /// The number of child nodes of this node.
  @ffi.UnsignedInt()
  external int mNumChildren;

  /// The child nodes of this node. nullptr if mNumChildren is 0.
  external ffi.Pointer<ffi.Pointer<aiNode>> mChildren;

  /// The number of meshes of this node.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The meshes of this node. Each entry is an index into the
  /// mesh list of the #aiScene.
  external ffi.Pointer<ffi.UnsignedInt> mMeshes;

  /// Metadata associated with this node or nullptr if there is no metadata.
  /// Whether any metadata is generated depends on the source file format. See the
  /// @link importer_notes @endlink page for more information on every source file
  /// format. Importers that don't document any metadata don't write any.
  external ffi.Pointer<aiMetadata> mMetaData;
}

/// @brief A single bone of a mesh.
///
/// A bone has a name by which it can be found in the frame hierarchy and by
/// which it can be addressed by animations. In addition it has a number of
/// influences on vertices, and a matrix relating the mesh position to the
/// position of the bone at the time of binding.
final class aiBone extends ffi.Struct {
  /// The name of the bone.
  external aiString mName;

  /// The number of vertices affected by this bone.
  /// The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
  @ffi.UnsignedInt()
  external int mNumWeights;

  /// The bone armature node - used for skeleton conversion
  /// you must enable aiProcess_PopulateArmatureData to populate this
  external ffi.Pointer<aiNode> mArmature;

  /// The bone node in the scene - used for skeleton conversion
  /// you must enable aiProcess_PopulateArmatureData to populate this
  external ffi.Pointer<aiNode> mNode;

  /// The influence weights of this bone, by vertex index.
  external ffi.Pointer<aiVertexWeight> mWeights;

  /// Matrix that transforms from mesh space to bone space in bind pose.
  ///
  /// This matrix describes the position of the mesh
  /// in the local space of this bone when the skeleton was bound.
  /// Thus it can be used directly to determine a desired vertex position,
  /// given the world-space transform of the bone when animated,
  /// and the position of the vertex in mesh space.
  ///
  /// It is sometimes called an inverse-bind matrix,
  /// or inverse bind pose matrix.
  external aiMatrix4x4 mOffsetMatrix;
}

/// @brief Enumerates the types of geometric primitives supported by Assimp.
///
/// @see aiFace Face data structure
/// @see aiProcess_SortByPType Per-primitive sorting of meshes
/// @see aiProcess_Triangulate Automatic triangulation
/// @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
enum aiPrimitiveType {
  /// @brief A point primitive.
  ///
  /// This is just a single vertex in the virtual world,
  /// #aiFace contains just one index for such a primitive.
  aiPrimitiveType_POINT(1),

  /// @brief A line primitive.
  ///
  /// This is a line defined through a start and an end position.
  /// #aiFace contains exactly two indices for such a primitive.
  aiPrimitiveType_LINE(2),

  /// @brief A triangular primitive.
  ///
  /// A triangle consists of three indices.
  aiPrimitiveType_TRIANGLE(4),

  /// @brief A higher-level polygon with more than 3 edges.
  ///
  /// A triangle is a polygon, but polygon in this context means
  /// "all polygons that are not triangles". The "Triangulate"-Step
  /// is provided for your convenience, it splits all polygons in
  /// triangles (which are much easier to handle).
  aiPrimitiveType_POLYGON(8),

  /// @brief A flag to determine whether this triangles only mesh is NGON encoded.
  ///
  /// NGON encoding is a special encoding that tells whether 2 or more consecutive triangles
  /// should be considered as a triangle fan. This is identified by looking at the first vertex index.
  /// 2 consecutive triangles with the same 1st vertex index are part of the same
  /// NGON.
  ///
  /// At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as
  /// triangles, as usual after a triangulation pass.
  ///
  /// To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.
  ///
  /// @see aiProcess_Triangulate
  /// @link https://github.com/KhronosGroup/glTF/pull/1620
  aiPrimitiveType_NGONEncodingFlag(16),
  _aiPrimitiveType_Force32Bit(2147483647);

  final int value;
  const aiPrimitiveType(this.value);

  static aiPrimitiveType fromValue(int value) => switch (value) {
        1 => aiPrimitiveType_POINT,
        2 => aiPrimitiveType_LINE,
        4 => aiPrimitiveType_TRIANGLE,
        8 => aiPrimitiveType_POLYGON,
        16 => aiPrimitiveType_NGONEncodingFlag,
        2147483647 => _aiPrimitiveType_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiPrimitiveType: $value'),
      };
}

/// @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
/// animations for a particular frame.
///
/// You may think of an #aiAnimMesh as a `patch` for the host mesh, which
/// replaces only certain vertex data streams at a particular time.
/// Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
/// The actual relationship between the time line and anim meshes is
/// established by #aiMeshAnim, which references singular mesh attachments
/// by their ID and binds them to a time offset.
final class aiAnimMesh extends ffi.Struct {
  /// Anim Mesh name
  external aiString mName;

  /// Replacement for aiMesh::mVertices. If this array is non-nullptr,
  /// it *must* contain mNumVertices entries. The corresponding
  /// array in the host mesh must be non-nullptr as well - animation
  /// meshes may neither add or nor remove vertex components (if
  /// a replacement array is nullptr and the corresponding source
  /// array is not, the source data is taken instead)
  external ffi.Pointer<aiVector3D> mVertices;

  /// Replacement for aiMesh::mNormals.
  external ffi.Pointer<aiVector3D> mNormals;

  /// Replacement for aiMesh::mTangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// Replacement for aiMesh::mBitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  /// Replacement for aiMesh::mColors
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  /// Replacement for aiMesh::mTextureCoords
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  /// The number of vertices in the aiAnimMesh, and thus the length of all
  /// the member arrays.
  ///
  /// This has always the same value as the mNumVertices property in the
  /// corresponding aiMesh. It is duplicated here merely to make the length
  /// of the member arrays accessible even if the aiMesh is not known, e.g.
  /// from language bindings.
  @ffi.UnsignedInt()
  external int mNumVertices;

  /// Weight of the AnimMesh.
  @ffi.Float()
  external double mWeight;
}

/// @brief Enumerates the methods of mesh morphing supported by Assimp.
enum aiMorphingMethod {
  /// Morphing method to be determined
  aiMorphingMethod_UNKNOWN(0),

  /// Interpolation between morph targets
  aiMorphingMethod_VERTEX_BLEND(1),

  /// Normalized morphing between morph targets
  aiMorphingMethod_MORPH_NORMALIZED(2),

  /// Relative morphing between morph targets
  aiMorphingMethod_MORPH_RELATIVE(3),
  _aiMorphingMethod_Force32Bit(2147483647);

  final int value;
  const aiMorphingMethod(this.value);

  static aiMorphingMethod fromValue(int value) => switch (value) {
        0 => aiMorphingMethod_UNKNOWN,
        1 => aiMorphingMethod_VERTEX_BLEND,
        2 => aiMorphingMethod_MORPH_NORMALIZED,
        3 => aiMorphingMethod_MORPH_RELATIVE,
        2147483647 => _aiMorphingMethod_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiMorphingMethod: $value'),
      };
}

/// @brief A mesh represents a geometry or model with a single material.
///
/// It usually consists of a number of vertices and a series of primitives/faces
/// referencing the vertices. In addition there might be a series of bones, each
/// of them addressing a number of vertices with a certain weight. Vertex data
/// is presented in channels with each channel containing a single per-vertex
/// information such as a set of texture coordinates or a normal vector.
/// If a data pointer is non-null, the corresponding data stream is present.
/// From C++-programs you can also use the comfort functions Has*() to
/// test for the presence of various data streams.
///
/// A Mesh uses only a single material which is referenced by a material ID.
/// @note The mPositions member is usually not optional. However, vertex positions
/// *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in
/// @code
/// aiScene::mFlags
/// @endcode
final class aiMesh extends ffi.Struct {
  /// Bitwise combination of the members of the #aiPrimitiveType enum.
  /// This specifies which types of primitives are present in the mesh.
  /// The "SortByPrimitiveType"-Step can be used to make sure the
  /// output meshes consist of one primitive type each.
  @ffi.UnsignedInt()
  external int mPrimitiveTypes;

  /// The number of vertices in this mesh.
  /// This is also the size of all of the per-vertex data arrays.
  /// The maximum value for this member is #AI_MAX_VERTICES.
  @ffi.UnsignedInt()
  external int mNumVertices;

  /// The number of primitives (triangles, polygons, lines) in this  mesh.
  /// This is also the size of the mFaces array.
  /// The maximum value for this member is #AI_MAX_FACES.
  @ffi.UnsignedInt()
  external int mNumFaces;

  /// @brief Vertex positions.
  ///
  /// This array is always present in a mesh. The array is
  /// mNumVertices in size.
  external ffi.Pointer<aiVector3D> mVertices;

  /// @brief Vertex normals.
  ///
  /// The array contains normalized vectors, nullptr if not present.
  /// The array is mNumVertices in size. Normals are undefined for
  /// point and line primitives. A mesh consisting of points and
  /// lines only may not have normal vectors. Meshes with mixed
  /// primitive types (i.e. lines and triangles) may have normals,
  /// but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to QNaN (WARN:
  /// qNaN compares to inequal to *everything*, even to qNaN itself.
  /// Using code like this to check whether a field is qnan is:
  /// @code
  /// #define IS_QNAN(f) (f != f)
  /// @endcode
  /// still dangerous because even 1.f == 1.f could evaluate to false! (
  /// remember the subtleties of IEEE754 artithmetics). Use stuff like
  /// @c fpclassify instead.
  /// @note Normal vectors computed by Assimp are always unit-length.
  /// However, this needn't apply for normals that have been taken
  /// directly from the model file.
  external ffi.Pointer<aiVector3D> mNormals;

  /// @brief Vertex tangents.
  ///
  /// The tangent of a vertex points in the direction of the positive
  /// X texture axis. The array contains normalized vectors, nullptr if
  /// not present. The array is mNumVertices in size. A mesh consisting
  /// of points and lines only may not have normal vectors. Meshes with
  /// mixed primitive types (i.e. lines and triangles) may have
  /// normals, but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to qNaN.  See
  /// the #mNormals member for a detailed discussion of qNaNs.
  /// @note If the mesh contains tangents, it automatically also
  /// contains bitangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// @brief Vertex bitangents.
  ///
  /// The bitangent of a vertex points in the direction of the positive
  /// Y texture axis. The array contains normalized vectors, nullptr if not
  /// present. The array is mNumVertices in size.
  /// @note If the mesh contains tangents, it automatically also contains
  /// bitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  /// @brief Vertex color sets.
  ///
  /// A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex
  /// colors per vertex. nullptr if not present. Each array is
  /// mNumVertices in size if present.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  /// @brief Vertex texture coordinates, also known as UV channels.
  ///
  /// A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS channels per
  /// vertex. Used and unused (nullptr) channels may go in any order.
  /// The array is mNumVertices in size.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  /// @brief Specifies the number of components for a given UV channel.
  ///
  /// Up to three channels are supported (UVW, for accessing volume
  /// or cube maps). If the value is 2 for a given channel n, the
  /// component p.z of mTextureCoords[n][p] is set to 0.0f.
  /// If the value is 1 for a given channel, p.y is set to 0.0f, too.
  /// @note 4D coordinates are not supported
  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> mNumUVComponents;

  /// @brief The faces the mesh is constructed from.
  ///
  /// Each face refers to a number of vertices by their indices.
  /// This array is always present in a mesh, its size is given
  /// in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
  /// is NOT set each face references an unique set of vertices.
  external ffi.Pointer<aiFace> mFaces;

  /// The number of bones this mesh contains. Can be 0, in which case the mBones array is nullptr.
  @ffi.UnsignedInt()
  external int mNumBones;

  /// @brief The bones of this mesh.
  ///
  /// A bone consists of a name by which it can be found in the
  /// frame hierarchy and a set of vertex weights.
  external ffi.Pointer<ffi.Pointer<aiBone>> mBones;

  /// @brief The material used by this mesh.
  ///
  /// A mesh uses only a single material. If an imported model uses
  /// multiple materials, the import splits up the mesh. Use this value
  /// as index into the scene's material list.
  @ffi.UnsignedInt()
  external int mMaterialIndex;

  /// Name of the mesh. Meshes can be named, but this is not a
  /// requirement and leaving this field empty is totally fine.
  /// There are mainly three uses for mesh names:
  /// - some formats name nodes and meshes independently.
  /// - importers tend to split meshes up to meet the
  /// one-material-per-mesh requirement. Assigning
  /// the same (dummy) name to each of the result meshes
  /// aids the caller at recovering the original mesh
  /// partitioning.
  /// - Vertex animations refer to meshes by their names.
  external aiString mName;

  /// The number of attachment meshes.
  /// Currently known to work with loaders:
  /// - Collada
  /// - gltf
  @ffi.UnsignedInt()
  external int mNumAnimMeshes;

  /// Attachment meshes for this mesh, for vertex-based animation.
  /// Attachment meshes carry replacement data for some of the
  /// mesh'es vertex components (usually positions, normals).
  /// Currently known to work with loaders:
  /// - Collada
  /// - gltf
  external ffi.Pointer<ffi.Pointer<aiAnimMesh>> mAnimMeshes;

  /// Method of morphing when anim-meshes are specified.
  /// @see aiMorphingMethod to learn more about the provided morphing targets.
  @ffi.UnsignedInt()
  external int mMethodAsInt;

  aiMorphingMethod get mMethod => aiMorphingMethod.fromValue(mMethodAsInt);

  /// The bounding box.
  external aiAABB mAABB;

  /// Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS
  external ffi.Pointer<ffi.Pointer<aiString>> mTextureCoordsNames;
}

/// @brief  A skeleton bone represents a single bone is a skeleton structure.
///
/// Skeleton-Animations can be represented via a skeleton struct, which describes
/// a hierarchical tree assembled from skeleton bones. A bone is linked to a mesh.
/// The bone knows its parent bone. If there is no parent bone the parent id is
/// marked with -1.
/// The skeleton-bone stores a pointer to its used armature. If there is no
/// armature this value if set to nullptr.
/// A skeleton bone stores its offset-matrix, which is the absolute transformation
/// for the bone. The bone stores the locale transformation to its parent as well.
/// You can compute the offset matrix by multiplying the hierarchy like:
/// Tree: s1 -> s2 -> s3
/// Offset-Matrix s3 = locale-s3 * locale-s2 * locale-s1
final class aiSkeletonBone extends ffi.Struct {
  /// The parent bone index, is -1 one if this bone represents the root bone.
  @ffi.Int()
  external int mParent;

  /// @brief The bone armature node - used for skeleton conversion
  /// you must enable aiProcess_PopulateArmatureData to populate this
  external ffi.Pointer<aiNode> mArmature;

  /// @brief The bone node in the scene - used for skeleton conversion
  /// you must enable aiProcess_PopulateArmatureData to populate this
  external ffi.Pointer<aiNode> mNode;

  /// @brief The number of weights
  @ffi.UnsignedInt()
  external int mNumnWeights;

  /// The mesh index, which will get influenced by the weight.
  external ffi.Pointer<aiMesh> mMeshId;

  /// The influence weights of this bone, by vertex index.
  external ffi.Pointer<aiVertexWeight> mWeights;

  /// Matrix that transforms from bone space to mesh space in bind pose.
  ///
  /// This matrix describes the position of the mesh
  /// in the local space of this bone when the skeleton was bound.
  /// Thus it can be used directly to determine a desired vertex position,
  /// given the world-space transform of the bone when animated,
  /// and the position of the vertex in mesh space.
  ///
  /// It is sometimes called an inverse-bind matrix,
  /// or inverse bind pose matrix.
  external aiMatrix4x4 mOffsetMatrix;

  /// Matrix that transforms the locale bone in bind pose.
  external aiMatrix4x4 mLocalMatrix;
}

/// @brief A skeleton represents the bone hierarchy of an animation.
///
/// Skeleton animations can be described as a tree of bones:
/// root
/// |
/// node1
/// /   \
/// node3  node4
/// If you want to calculate the transformation of node three you need to compute the
/// transformation hierarchy for the transformation chain of node3:
/// root->node1->node3
/// Each node is represented as a skeleton instance.
final class aiSkeleton extends ffi.Struct {
  /// @brief The name of the skeleton instance.
  external aiString mName;

  /// @brief  The number of bones in the skeleton.
  @ffi.UnsignedInt()
  external int mNumBones;

  /// @brief The bone instance in the skeleton.
  external ffi.Pointer<ffi.Pointer<aiSkeletonBone>> mBones;
}

/// Enumerates all supported types of light sources.
enum aiLightSourceType {
  aiLightSource_UNDEFINED(0),

  /// ! A directional light source has a well-defined direction
  /// ! but is infinitely far away. That's quite a good
  /// ! approximation for sun light.
  aiLightSource_DIRECTIONAL(1),

  /// ! A point light source has a well-defined position
  /// ! in space but no direction - it emits light in all
  /// ! directions. A normal bulb is a point light.
  aiLightSource_POINT(2),

  /// ! A spot light source emits light in a specific
  /// ! angle. It has a position and a direction it is pointing to.
  /// ! A good example for a spot light is a light spot in
  /// ! sport arenas.
  aiLightSource_SPOT(3),

  /// ! The generic light level of the world, including the bounces
  /// ! of all other light sources.
  /// ! Typically, there's at most one ambient light in a scene.
  /// ! This light type doesn't have a valid position, direction, or
  /// ! other properties, just a color.
  aiLightSource_AMBIENT(4),

  /// ! An area light is a rectangle with predefined size that uniformly
  /// ! emits light from one of its sides. The position is center of the
  /// ! rectangle and direction is its normal vector.
  aiLightSource_AREA(5),
  _aiLightSource_Force32Bit(2147483647);

  final int value;
  const aiLightSourceType(this.value);

  static aiLightSourceType fromValue(int value) => switch (value) {
        0 => aiLightSource_UNDEFINED,
        1 => aiLightSource_DIRECTIONAL,
        2 => aiLightSource_POINT,
        3 => aiLightSource_SPOT,
        4 => aiLightSource_AMBIENT,
        5 => aiLightSource_AREA,
        2147483647 => _aiLightSource_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiLightSourceType: $value'),
      };
}

/// Helper structure to describe a light source.
///
/// Assimp supports multiple sorts of light sources, including
/// directional, point and spot lights. All of them are defined with just
/// a single structure and distinguished by their parameters.
/// Note - some file formats (such as 3DS, ASE) export a "target point" -
/// the point a spot light is looking at (it can even be animated). Assimp
/// writes the target point as a sub-node of a spot-lights's main node,
/// called "<spotName>.Target". However, this is just additional information
/// then, the transformation tracks of the main node make the
/// spot light already point in the right direction.
final class aiLight extends ffi.Struct {
  /// The name of the light source.
  ///
  /// There must be a node in the scene-graph with the same name.
  /// This node specifies the position of the light in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// The type of the light source.
  ///
  /// aiLightSource_UNDEFINED is not a valid value for this member.
  @ffi.UnsignedInt()
  external int mTypeAsInt;

  aiLightSourceType get mType => aiLightSourceType.fromValue(mTypeAsInt);

  /// Position of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The position is undefined for directional lights.
  external aiVector3D mPosition;

  /// Direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mDirection;

  /// Up direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// Constant light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att0 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationConstant;

  /// Linear light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att1 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationLinear;

  /// Quadratic light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att2 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationQuadratic;

  /// Diffuse color of the light source
  ///
  /// The diffuse light color is multiplied with the diffuse
  /// material color to obtain the final color that contributes
  /// to the diffuse shading term.
  external aiColor3D mColorDiffuse;

  /// Specular color of the light source
  ///
  /// The specular light color is multiplied with the specular
  /// material color to obtain the final color that contributes
  /// to the specular shading term.
  external aiColor3D mColorSpecular;

  /// Ambient color of the light source
  ///
  /// The ambient light color is multiplied with the ambient
  /// material color to obtain the final color that contributes
  /// to the ambient shading term. Most renderers will ignore
  /// this value it, is just a remaining of the fixed-function pipeline
  /// that is still supported by quite many file formats.
  external aiColor3D mColorAmbient;

  /// Inner angle of a spot light's light cone.
  ///
  /// The spot light has maximum influence on objects inside this
  /// angle. The angle is given in radians. It is 2PI for point
  /// lights and undefined for directional lights.
  @ffi.Float()
  external double mAngleInnerCone;

  /// Outer angle of a spot light's light cone.
  ///
  /// The spot light does not affect objects outside this angle.
  /// The angle is given in radians. It is 2PI for point lights and
  /// undefined for directional lights. The outer angle must be
  /// greater than or equal to the inner angle.
  /// It is assumed that the application uses a smooth
  /// interpolation between the inner and the outer cone of the
  /// spot light.
  @ffi.Float()
  external double mAngleOuterCone;

  /// Size of area light source.
  external aiVector2D mSize;
}

/// Helper structure to describe a virtual camera.
///
/// Cameras have a representation in the node graph and can be animated.
/// An important aspect is that the camera itself is also part of the
/// scene-graph. This means, any values such as the look-at vector are not
/// *absolute*, they're <b>relative</b> to the coordinate system defined
/// by the node which corresponds to the camera. This allows for camera
/// animations. For static cameras parameters like the 'look-at' or 'up' vectors
/// are usually specified directly in aiCamera, but beware, they could also
/// be encoded in the node transformation. The following (pseudo)code sample
/// shows how to do it: <br><br>
/// @code
/// // Get the camera matrix for a camera at a specific time
/// // if the node hierarchy for the camera does not contain
/// // at least one animated node this is a static computation
/// get-camera-matrix (node sceneRoot, camera cam) : matrix
/// {
/// node   cnd = find-node-for-camera(cam)
/// matrix cmt = identity()
///
/// // as usual - get the absolute camera transformation for this frame
/// for each node nd in hierarchy from sceneRoot to cnd
/// matrix cur
/// if (is-animated(nd))
/// cur = eval-animation(nd)
/// else cur = nd->mTransformation;
/// cmt = mult-matrices( cmt, cur )
/// end for
///
/// // now multiply with the camera's own local transform
/// cam = mult-matrices (cam, get-camera-matrix(cmt) )
/// }
/// @endcode
///
/// @note some file formats (such as 3DS, ASE) export a "target point" -
/// the point the camera is looking at (it can even be animated). Assimp
/// writes the target point as a subnode of the camera's main node,
/// called "<camName>.Target". However this is just additional information
/// then the transformation tracks of the camera main node make the
/// camera already look in the right direction.
final class aiCamera extends ffi.Struct {
  /// The name of the camera.
  ///
  /// There must be a node in the scenegraph with the same name.
  /// This node specifies the position of the camera in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// Position of the camera relative to the coordinate space
  /// defined by the corresponding node.
  ///
  /// The default value is 0|0|0.
  external aiVector3D mPosition;

  /// 'Up' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// The 'right' vector of the camera coordinate system is
  /// the cross product of  the up and lookAt vectors.
  /// The default value is 0|1|0. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// 'LookAt' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// This is the viewing direction of the user.
  /// The default value is 0|0|1. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mLookAt;

  /// Horizontal field of view angle, in radians.
  ///
  /// The field of view angle is the angle between the center
  /// line of the screen and the left or right border.
  /// The default value is 1/4PI.
  @ffi.Float()
  external double mHorizontalFOV;

  /// Distance of the near clipping plane from the camera.
  ///
  /// The value may not be 0.f (for arithmetic reasons to prevent
  /// a division through zero). The default value is 0.1f.
  @ffi.Float()
  external double mClipPlaneNear;

  /// Distance of the far clipping plane from the camera.
  ///
  /// The far clipping plane must, of course, be further away than the
  /// near clipping plane. The default value is 1000.f. The ratio
  /// between the near and the far plane should not be too
  /// large (between 1000-10000 should be ok) to avoid floating-point
  /// inaccuracies which could lead to z-fighting.
  @ffi.Float()
  external double mClipPlaneFar;

  /// Screen aspect ratio.
  ///
  /// This is the ration between the width and the height of the
  /// screen. Typical values are 4/3, 1/2 or 1/1. This value is
  /// 0 if the aspect ratio is not defined in the source file.
  /// 0 is also the default value.
  @ffi.Float()
  external double mAspect;

  /// Half horizontal orthographic width, in scene units.
  ///
  /// The orthographic width specifies the half width of the
  /// orthographic view box. If non-zero the camera is
  /// orthographic and the mAspect should define to the
  /// ratio between the orthographic width and height
  /// and mHorizontalFOV should be set to 0.
  /// The default value is 0 (not orthographic).
  @ffi.Float()
  external double mOrthographicWidth;
}

/// @brief Defines how the Nth texture of a specific type is combined with
/// the result of all previous layers.
///
/// Example (left: key, right: value): <br>
/// @code
/// DiffColor0     - gray
/// DiffTextureOp0 - aiTextureOpMultiply
/// DiffTexture0   - tex1.png
/// DiffTextureOp0 - aiTextureOpAdd
/// DiffTexture1   - tex2.png
/// @endcode
/// Written as equation, the final diffuse term for a specific pixel would be:
/// @code
/// diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +
/// sampleTex(DiffTexture1,UV0) * diffContrib;
/// @endcode
/// where 'diffContrib' is the intensity of the incoming light for that pixel.
enum aiTextureOp {
  /// T = T1 * T2
  aiTextureOp_Multiply(0),

  /// T = T1 + T2
  aiTextureOp_Add(1),

  /// T = T1 - T2
  aiTextureOp_Subtract(2),

  /// T = T1 / T2
  aiTextureOp_Divide(3),

  /// T = (T1 + T2) - (T1 * T2)
  aiTextureOp_SmoothAdd(4),

  /// T = T1 + (T2-0.5)
  aiTextureOp_SignedAdd(5),
  _aiTextureOp_Force32Bit(2147483647);

  final int value;
  const aiTextureOp(this.value);

  static aiTextureOp fromValue(int value) => switch (value) {
        0 => aiTextureOp_Multiply,
        1 => aiTextureOp_Add,
        2 => aiTextureOp_Subtract,
        3 => aiTextureOp_Divide,
        4 => aiTextureOp_SmoothAdd,
        5 => aiTextureOp_SignedAdd,
        2147483647 => _aiTextureOp_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiTextureOp: $value'),
      };
}

/// @brief Defines how UV coordinates outside the [0...1] range are handled.
///
/// Commonly referred to as 'wrapping mode'.
enum aiTextureMapMode {
  /// A texture coordinate u|v is translated to u%1|v%1
  aiTextureMapMode_Wrap(0),

  /// Texture coordinates outside [0...1]
  /// are clamped to the nearest valid value.
  aiTextureMapMode_Clamp(1),

  /// If the texture coordinates for a pixel are outside [0...1]
  /// the texture is not applied to that pixel
  aiTextureMapMode_Decal(3),

  /// A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and
  /// 1-(u%1)|1-(v%1) otherwise
  aiTextureMapMode_Mirror(2),
  _aiTextureMapMode_Force32Bit(2147483647);

  final int value;
  const aiTextureMapMode(this.value);

  static aiTextureMapMode fromValue(int value) => switch (value) {
        0 => aiTextureMapMode_Wrap,
        1 => aiTextureMapMode_Clamp,
        3 => aiTextureMapMode_Decal,
        2 => aiTextureMapMode_Mirror,
        2147483647 => _aiTextureMapMode_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiTextureMapMode: $value'),
      };
}

/// @brief Defines how the mapping coords for a texture are generated.
///
/// Real-time applications typically require full UV coordinates, so the use of
/// the aiProcess_GenUVCoords step is highly recommended. It generates proper
/// UV channels for non-UV mapped objects, as long as an accurate description
/// how the mapping should look like (e.g spherical) is given.
/// See the #AI_MATKEY_MAPPING property for more details.
enum aiTextureMapping {
  /// The mapping coordinates are taken from an UV channel.
  ///
  /// #AI_MATKEY_UVWSRC property specifies from which UV channel
  /// the texture coordinates are to be taken from (remember,
  /// meshes can have more than one UV channel).
  aiTextureMapping_UV(0),

  /// Spherical mapping
  aiTextureMapping_SPHERE(1),

  /// Cylindrical mapping
  aiTextureMapping_CYLINDER(2),

  /// Cubic mapping
  aiTextureMapping_BOX(3),

  /// Planar mapping
  aiTextureMapping_PLANE(4),

  /// Undefined mapping. Have fun.
  aiTextureMapping_OTHER(5),
  _aiTextureMapping_Force32Bit(2147483647);

  final int value;
  const aiTextureMapping(this.value);

  static aiTextureMapping fromValue(int value) => switch (value) {
        0 => aiTextureMapping_UV,
        1 => aiTextureMapping_SPHERE,
        2 => aiTextureMapping_CYLINDER,
        3 => aiTextureMapping_BOX,
        4 => aiTextureMapping_PLANE,
        5 => aiTextureMapping_OTHER,
        2147483647 => _aiTextureMapping_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiTextureMapping: $value'),
      };
}

/// @brief Defines the purpose of a texture
///
/// This is a very difficult topic. Different 3D packages support different
/// kinds of textures. For very common texture types, such as bumpmaps, the
/// rendering results depend on implementation details in the rendering
/// pipelines of these applications. Assimp loads all texture references from
/// the model file and tries to determine which of the predefined texture
/// types below is the best choice to match the original use of the texture
/// as closely as possible.<br>
///
/// In content pipelines you'll usually define how textures have to be handled,
/// and the artists working on models have to conform to this specification,
/// regardless which 3D tool they're using.
enum aiTextureType {
  /// Dummy value.
  ///
  /// No texture, but the value to be used as 'texture semantic'
  /// (#aiMaterialProperty::mSemantic) for all material properties
  /// *not* related to textures.
  aiTextureType_NONE(0),

  /// The texture is combined with the result of the diffuse
  /// lighting equation.
  /// OR
  /// PBR Specular/Glossiness
  aiTextureType_DIFFUSE(1),

  /// The texture is combined with the result of the specular
  /// lighting equation.
  /// OR
  /// PBR Specular/Glossiness
  aiTextureType_SPECULAR(2),

  /// The texture is combined with the result of the ambient
  /// lighting equation.
  aiTextureType_AMBIENT(3),

  /// The texture is added to the result of the lighting
  /// calculation. It isn't influenced by incoming light.
  aiTextureType_EMISSIVE(4),

  /// The texture is a height map.
  ///
  /// By convention, higher gray-scale values stand for
  /// higher elevations from the base height.
  aiTextureType_HEIGHT(5),

  /// The texture is a (tangent space) normal-map.
  ///
  /// Again, there are several conventions for tangent-space
  /// normal maps. Assimp does (intentionally) not
  /// distinguish here.
  aiTextureType_NORMALS(6),

  /// The texture defines the glossiness of the material.
  ///
  /// The glossiness is in fact the exponent of the specular
  /// (phong) lighting equation. Usually there is a conversion
  /// function defined to map the linear color values in the
  /// texture to a suitable exponent. Have fun.
  aiTextureType_SHININESS(7),

  /// The texture defines per-pixel opacity.
  ///
  /// Usually 'white' means opaque and 'black' means
  /// 'transparency'. Or quite the opposite. Have fun.
  aiTextureType_OPACITY(8),

  /// Displacement texture
  ///
  /// The exact purpose and format is application-dependent.
  /// Higher color values stand for higher vertex displacements.
  aiTextureType_DISPLACEMENT(9),

  /// Lightmap texture (aka Ambient Occlusion)
  ///
  /// Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
  /// covered by this material property. The texture contains a
  /// scaling value for the final color value of a pixel. Its
  /// intensity is not affected by incoming light.
  aiTextureType_LIGHTMAP(10),

  /// Reflection texture
  ///
  /// Contains the color of a perfect mirror reflection.
  /// Rarely used, almost never for real-time applications.
  aiTextureType_REFLECTION(11),

  /// PBR Materials
  /// PBR definitions from maya and other modelling packages now use this standard.
  /// This was originally introduced around 2012.
  /// Support for this is in game engines like Godot, Unreal or Unity3D.
  /// Modelling packages which use this are very common now.
  aiTextureType_BASE_COLOR(12),
  aiTextureType_NORMAL_CAMERA(13),
  aiTextureType_EMISSION_COLOR(14),
  aiTextureType_METALNESS(15),
  aiTextureType_DIFFUSE_ROUGHNESS(16),
  aiTextureType_AMBIENT_OCCLUSION(17),

  /// Unknown texture
  ///
  /// A texture reference that does not match any of the definitions
  /// above is considered to be 'unknown'. It is still imported,
  /// but is excluded from any further post-processing.
  aiTextureType_UNKNOWN(18),

  /// Sheen
  /// Generally used to simulate textiles that are covered in a layer of microfibers
  /// eg velvet
  /// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen
  aiTextureType_SHEEN(19),

  /// Clearcoat
  /// Simulates a layer of 'polish' or 'lacquer' layered on top of a PBR substrate
  /// https://autodesk.github.io/standard-surface/#closures/coating
  /// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
  aiTextureType_CLEARCOAT(20),

  /// Transmission
  /// Simulates transmission through the surface
  /// May include further information such as wall thickness
  aiTextureType_TRANSMISSION(21),

  /// Maya material declarations
  aiTextureType_MAYA_BASE(22),
  aiTextureType_MAYA_SPECULAR(23),
  aiTextureType_MAYA_SPECULAR_COLOR(24),
  aiTextureType_MAYA_SPECULAR_ROUGHNESS(25),

  /// Anisotropy
  /// Simulates a surface with directional properties
  aiTextureType_ANISOTROPY(26),

  /// gltf material declarations
  /// Refs: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#metallic-roughness-material
  /// "textures for metalness and roughness properties are packed together in a single
  /// texture called metallicRoughnessTexture. Its green channel contains roughness
  /// values and its blue channel contains metalness values..."
  /// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_material_pbrmetallicroughness_metallicroughnesstexture
  /// "The metalness values are sampled from the B channel. The roughness values are
  /// sampled from the G channel..."
  aiTextureType_GLTF_METALLIC_ROUGHNESS(27),
  _aiTextureType_Force32Bit(2147483647);

  final int value;
  const aiTextureType(this.value);

  static aiTextureType fromValue(int value) => switch (value) {
        0 => aiTextureType_NONE,
        1 => aiTextureType_DIFFUSE,
        2 => aiTextureType_SPECULAR,
        3 => aiTextureType_AMBIENT,
        4 => aiTextureType_EMISSIVE,
        5 => aiTextureType_HEIGHT,
        6 => aiTextureType_NORMALS,
        7 => aiTextureType_SHININESS,
        8 => aiTextureType_OPACITY,
        9 => aiTextureType_DISPLACEMENT,
        10 => aiTextureType_LIGHTMAP,
        11 => aiTextureType_REFLECTION,
        12 => aiTextureType_BASE_COLOR,
        13 => aiTextureType_NORMAL_CAMERA,
        14 => aiTextureType_EMISSION_COLOR,
        15 => aiTextureType_METALNESS,
        16 => aiTextureType_DIFFUSE_ROUGHNESS,
        17 => aiTextureType_AMBIENT_OCCLUSION,
        18 => aiTextureType_UNKNOWN,
        19 => aiTextureType_SHEEN,
        20 => aiTextureType_CLEARCOAT,
        21 => aiTextureType_TRANSMISSION,
        22 => aiTextureType_MAYA_BASE,
        23 => aiTextureType_MAYA_SPECULAR,
        24 => aiTextureType_MAYA_SPECULAR_COLOR,
        25 => aiTextureType_MAYA_SPECULAR_ROUGHNESS,
        26 => aiTextureType_ANISOTROPY,
        27 => aiTextureType_GLTF_METALLIC_ROUGHNESS,
        2147483647 => _aiTextureType_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiTextureType: $value'),
      };
}

/// @brief Defines all shading models supported by the library
///
/// Property: #AI_MATKEY_SHADING_MODEL
///
/// The list of shading modes has been taken from Blender.
/// See Blender documentation for more information. The API does
/// not distinguish between "specular" and "diffuse" shaders (thus the
/// specular term for diffuse shading models like Oren-Nayar remains
/// undefined). <br>
/// Again, this value is just a hint. Assimp tries to select the shader whose
/// most common implementation matches the original rendering results of the
/// 3D modeler which wrote a particular model as closely as possible.
enum aiShadingMode {
  /// Flat shading. Shading is done on per-face base,
  /// diffuse only. Also known as 'faceted shading'.
  aiShadingMode_Flat(1),

  /// Simple Gouraud shading.
  aiShadingMode_Gouraud(2),

  /// Phong-Shading -
  aiShadingMode_Phong(3),

  /// Phong-Blinn-Shading
  aiShadingMode_Blinn(4),

  /// Toon-Shading per pixel
  ///
  /// Also known as 'comic' shader.
  aiShadingMode_Toon(5),

  /// OrenNayar-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// roughness of the material into account
  aiShadingMode_OrenNayar(6),

  /// Minnaert-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// "darkness" of the material into account
  aiShadingMode_Minnaert(7),

  /// CookTorrance-Shading per pixel
  ///
  /// Special shader for metallic surfaces.
  aiShadingMode_CookTorrance(8),

  /// No shading at all. Constant light influence of 1.0.
  /// Also known as "Unlit"
  aiShadingMode_NoShading(9),

  /// Fresnel shading
  aiShadingMode_Fresnel(10),

  /// Physically-Based Rendering (PBR) shading using
  /// Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
  /// There are multiple methods under this banner, and model files may provide
  /// data for more than one PBR-BRDF method.
  /// Applications should use the set of provided properties to determine which
  /// of their preferred PBR rendering methods are likely to be available
  /// eg:
  /// - If AI_MATKEY_METALLIC_FACTOR is set, then a Metallic/Roughness is available
  /// - If AI_MATKEY_GLOSSINESS_FACTOR is set, then a Specular/Glossiness is available
  /// Note that some PBR methods allow layering of techniques
  aiShadingMode_PBR_BRDF(11),
  _aiShadingMode_Force32Bit(2147483647);

  static const aiShadingMode_Unlit = aiShadingMode_NoShading;

  final int value;
  const aiShadingMode(this.value);

  static aiShadingMode fromValue(int value) => switch (value) {
        1 => aiShadingMode_Flat,
        2 => aiShadingMode_Gouraud,
        3 => aiShadingMode_Phong,
        4 => aiShadingMode_Blinn,
        5 => aiShadingMode_Toon,
        6 => aiShadingMode_OrenNayar,
        7 => aiShadingMode_Minnaert,
        8 => aiShadingMode_CookTorrance,
        9 => aiShadingMode_NoShading,
        10 => aiShadingMode_Fresnel,
        11 => aiShadingMode_PBR_BRDF,
        2147483647 => _aiShadingMode_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiShadingMode: $value'),
      };

  @override
  String toString() {
    if (this == aiShadingMode_NoShading)
      return "aiShadingMode.aiShadingMode_NoShading, aiShadingMode.aiShadingMode_Unlit";
    return super.toString();
  }
}

/// @brief Defines some mixed flags for a particular texture.
///
/// Usually you'll instruct your cg artists how textures have to look like ...
/// and how they will be processed in your application. However, if you use
/// Assimp for completely generic loading purposes you might also need to
/// process these flags in order to display as many 'unknown' 3D models as
/// possible correctly.
///
/// This corresponds to the #AI_MATKEY_TEXFLAGS property.
enum aiTextureFlags {
  /// The texture's color values have to be inverted (component-wise 1-n)
  aiTextureFlags_Invert(1),

  /// Explicit request to the application to process the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These
  /// flags are set if the library can say for sure that the alpha
  /// channel is used/is not used. If the model format does not
  /// define this, it is left to the application to decide whether
  /// the texture alpha channel - if any - is evaluated or not.
  aiTextureFlags_UseAlpha(2),

  /// Explicit request to the application to ignore the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_UseAlpha.
  aiTextureFlags_IgnoreAlpha(4),
  _aiTextureFlags_Force32Bit(2147483647);

  final int value;
  const aiTextureFlags(this.value);

  static aiTextureFlags fromValue(int value) => switch (value) {
        1 => aiTextureFlags_Invert,
        2 => aiTextureFlags_UseAlpha,
        4 => aiTextureFlags_IgnoreAlpha,
        2147483647 => _aiTextureFlags_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiTextureFlags: $value'),
      };
}

/// @brief Defines alpha-blend flags.
///
/// If you're familiar with OpenGL or D3D, these flags aren't new to you.
/// They define *how* the final color value of a pixel is computed, basing
/// on the previous color at that pixel and the new color value from the
/// material.
/// The blend formula is:
/// @code
/// SourceColor * SourceBlend + DestColor * DestBlend
/// @endcode
/// where DestColor is the previous color in the frame-buffer at this
/// position and SourceColor is the material color before the transparency
/// calculation.<br>
/// This corresponds to the #AI_MATKEY_BLEND_FUNC property.
enum aiBlendMode {
  /// Formula:
  /// @code
  /// SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)
  /// @endcode
  aiBlendMode_Default(0),

  /// Additive blending
  ///
  /// Formula:
  /// @code
  /// SourceColor*1 + DestColor*1
  /// @endcode
  aiBlendMode_Additive(1),
  _aiBlendMode_Force32Bit(2147483647);

  final int value;
  const aiBlendMode(this.value);

  static aiBlendMode fromValue(int value) => switch (value) {
        0 => aiBlendMode_Default,
        1 => aiBlendMode_Additive,
        2147483647 => _aiBlendMode_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiBlendMode: $value'),
      };
}

/// @brief Defines how an UV channel is transformed.
///
/// This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
/// See its documentation for more details.
///
/// Typically you'll want to build a matrix of this information. However,
/// we keep separate scaling/translation/rotation values to make it
/// easier to process and optimize UV transformations internally.
final class aiUVTransform extends ffi.Struct {
  /// Translation on the u and v axes.
  ///
  /// The default value is (0|0).
  external aiVector2D mTranslation;

  /// Scaling on the u and v axes.
  ///
  /// The default value is (1|1).
  external aiVector2D mScaling;

  /// Rotation - in counter-clockwise direction.
  ///
  /// The rotation angle is specified in radians. The
  /// rotation center is 0.5f|0.5f. The default value
  /// 0.f.
  @ai_real()
  external double mRotation;
}

/// @brief A very primitive RTTI system for the contents of material properties.
enum aiPropertyTypeInfo {
  /// Array of single-precision (32 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  aiPTI_Float(1),

  /// Array of double-precision (64 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  aiPTI_Double(2),

  /// The material property is an aiString.
  ///
  /// Arrays of strings aren't possible, aiGetMaterialString() (or the
  /// C++-API aiMaterial::Get()) *must* be used to query a string property.
  aiPTI_String(3),

  /// Array of (32 Bit) integers
  ///
  /// It is possible to use aiGetMaterialFloat[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in integer format.
  /// The material system performs the type conversion automatically.
  aiPTI_Integer(4),

  /// Simple binary buffer, content undefined. Not convertible to anything.
  aiPTI_Buffer(5),
  _aiPTI_Force32Bit(2147483647);

  final int value;
  const aiPropertyTypeInfo(this.value);

  static aiPropertyTypeInfo fromValue(int value) => switch (value) {
        1 => aiPTI_Float,
        2 => aiPTI_Double,
        3 => aiPTI_String,
        4 => aiPTI_Integer,
        5 => aiPTI_Buffer,
        2147483647 => _aiPTI_Force32Bit,
        _ =>
          throw ArgumentError('Unknown value for aiPropertyTypeInfo: $value'),
      };
}

/// @brief Data structure for a single material property
///
/// As an user, you'll probably never need to deal with this data structure.
/// Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family
/// of functions to query material properties easily. Processing them
/// manually is faster, but it is not the recommended way. It isn't worth
/// the effort. <br>
/// Material property names follow a simple scheme:
/// @code
/// $<name>
/// ?<name>
/// A public property, there must be corresponding AI_MATKEY_XXX define
/// 2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials
/// post-processing step.
/// ~<name>
/// A temporary property for internal use.
/// @endcode
/// @see aiMaterial
final class aiMaterialProperty extends ffi.Struct {
  /// Specifies the name of the property (key)
  /// Keys are generally case insensitive.
  external aiString mKey;

  /// Textures: Specifies their exact usage semantic.
  /// For non-texture properties, this member is always 0
  /// (or, better-said, #aiTextureType_NONE).
  @ffi.UnsignedInt()
  external int mSemantic;

  /// Textures: Specifies the index of the texture.
  /// For non-texture properties, this member is always 0.
  @ffi.UnsignedInt()
  external int mIndex;

  /// Size of the buffer mData is pointing to, in bytes.
  /// This value may not be 0.
  @ffi.UnsignedInt()
  external int mDataLength;

  /// Type information for the property.
  ///
  /// Defines the data layout inside the data buffer. This is used
  /// by the library internally to perform debug checks and to
  /// utilize proper type conversions.
  /// (It's probably a hacky solution, but it works.)
  @ffi.UnsignedInt()
  external int mTypeAsInt;

  aiPropertyTypeInfo get mType => aiPropertyTypeInfo.fromValue(mTypeAsInt);

  /// Binary buffer to hold the property's value.
  /// The size of the buffer is always mDataLength.
  external ffi.Pointer<ffi.Char> mData;
}

final class aiMaterial extends ffi.Struct {
  /// List of all material properties loaded.
  external ffi.Pointer<ffi.Pointer<aiMaterialProperty>> mProperties;

  /// Number of properties in the data base
  @ffi.UnsignedInt()
  external int mNumProperties;

  /// Storage allocated
  @ffi.UnsignedInt()
  external int mNumAllocated;
}

///
enum aiAnimInterpolation {
  ///
  aiAnimInterpolation_Step(0),

  ///
  aiAnimInterpolation_Linear(1),

  ///
  aiAnimInterpolation_Spherical_Linear(2),

  ///
  aiAnimInterpolation_Cubic_Spline(3),
  _aiAnimInterpolation_Force32Bit(2147483647);

  final int value;
  const aiAnimInterpolation(this.value);

  static aiAnimInterpolation fromValue(int value) => switch (value) {
        0 => aiAnimInterpolation_Step,
        1 => aiAnimInterpolation_Linear,
        2 => aiAnimInterpolation_Spherical_Linear,
        3 => aiAnimInterpolation_Cubic_Spline,
        2147483647 => _aiAnimInterpolation_Force32Bit,
        _ =>
          throw ArgumentError('Unknown value for aiAnimInterpolation: $value'),
      };
}

/// A time-value pair specifying a certain 3D vector for the given time.
final class aiVectorKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiVector3D mValue;

  /// The interpolation setting of this key
  @ffi.UnsignedInt()
  external int mInterpolationAsInt;

  aiAnimInterpolation get mInterpolation =>
      aiAnimInterpolation.fromValue(mInterpolationAsInt);
}

/// A time-value pair specifying a rotation for the given time.
/// Rotations are expressed with quaternions.
final class aiQuatKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiQuaternion mValue;

  /// The interpolation setting of this key
  @ffi.UnsignedInt()
  external int mInterpolationAsInt;

  aiAnimInterpolation get mInterpolation =>
      aiAnimInterpolation.fromValue(mInterpolationAsInt);
}

/// Binds a anim-mesh to a specific point in time.
final class aiMeshKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// Index into the aiMesh::mAnimMeshes array of the
  /// mesh corresponding to the #aiMeshAnim hosting this
  /// key frame. The referenced anim mesh is evaluated
  /// according to the rules defined in the docs for #aiAnimMesh.
  @ffi.UnsignedInt()
  external int mValue;
}

/// Binds a morph anim mesh to a specific point in time.
final class aiMeshMorphKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The values and weights at the time of this key
  /// - mValues: index of attachment mesh to apply weight at the same position in mWeights
  /// - mWeights: weight to apply to the blend shape index at the same position in mValues
  external ffi.Pointer<ffi.UnsignedInt> mValues;

  external ffi.Pointer<ffi.Double> mWeights;

  /// The number of values and weights
  @ffi.UnsignedInt()
  external int mNumValuesAndWeights;
}

/// Defines how an animation channel behaves outside the defined time
/// range. This corresponds to aiNodeAnim::mPreState and
/// aiNodeAnim::mPostState.
enum aiAnimBehaviour {
  /// The value from the default node transformation is taken
  aiAnimBehaviour_DEFAULT(0),

  /// The nearest key value is used without interpolation
  aiAnimBehaviour_CONSTANT(1),

  /// The value of the nearest two keys is linearly
  /// extrapolated for the current time value.
  aiAnimBehaviour_LINEAR(2),

  /// The animation is repeated.
  ///
  /// If the animation key go from n to m and the current
  /// time is t, use the value at (t-n) % (|m-n|).
  aiAnimBehaviour_REPEAT(3),
  _aiAnimBehaviour_Force32Bit(2147483647);

  final int value;
  const aiAnimBehaviour(this.value);

  static aiAnimBehaviour fromValue(int value) => switch (value) {
        0 => aiAnimBehaviour_DEFAULT,
        1 => aiAnimBehaviour_CONSTANT,
        2 => aiAnimBehaviour_LINEAR,
        3 => aiAnimBehaviour_REPEAT,
        2147483647 => _aiAnimBehaviour_Force32Bit,
        _ => throw ArgumentError('Unknown value for aiAnimBehaviour: $value'),
      };
}

/// Describes the animation of a single node. The name specifies the
/// bone/node which is affected by this animation channel. The keyframes
/// are given in three separate series of values, one each for position,
/// rotation and scaling. The transformation matrix computed from these
/// values replaces the node's original transformation matrix at a
/// specific time.
/// This means all keys are absolute and not relative to the bone default pose.
/// The order in which the transformations are applied is
/// - as usual - scaling, rotation, translation.
///
/// @note All keys are returned in their correct, chronological order.
/// Duplicate keys don't pass the validation step. Most likely there
/// will be no negative time values, but they are not forbidden also ( so
/// implementations need to cope with them! )
final class aiNodeAnim extends ffi.Struct {
  /// The name of the node affected by this animation. The node
  /// must exist and it must be unique.
  external aiString mNodeName;

  /// The number of position keys
  @ffi.UnsignedInt()
  external int mNumPositionKeys;

  /// The position keys of this animation channel. Positions are
  /// specified as 3D vector. The array is mNumPositionKeys in size.
  ///
  /// If there are position keys, there will also be at least one
  /// scaling and one rotation key.
  external ffi.Pointer<aiVectorKey> mPositionKeys;

  /// The number of rotation keys
  @ffi.UnsignedInt()
  external int mNumRotationKeys;

  /// The rotation keys of this animation channel. Rotations are
  /// given as quaternions,  which are 4D vectors. The array is
  /// mNumRotationKeys in size.
  ///
  /// If there are rotation keys, there will also be at least one
  /// scaling and one position key.
  external ffi.Pointer<aiQuatKey> mRotationKeys;

  /// The number of scaling keys
  @ffi.UnsignedInt()
  external int mNumScalingKeys;

  /// The scaling keys of this animation channel. Scalings are
  /// specified as 3D vector. The array is mNumScalingKeys in size.
  ///
  /// If there are scaling keys, there will also be at least one
  /// position and one rotation key.
  external ffi.Pointer<aiVectorKey> mScalingKeys;

  /// Defines how the animation behaves before the first
  /// key is encountered.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is used).
  @ffi.UnsignedInt()
  external int mPreStateAsInt;

  aiAnimBehaviour get mPreState => aiAnimBehaviour.fromValue(mPreStateAsInt);

  /// Defines how the animation behaves after the last
  /// key was processed.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is taken).
  @ffi.UnsignedInt()
  external int mPostStateAsInt;

  aiAnimBehaviour get mPostState => aiAnimBehaviour.fromValue(mPostStateAsInt);
}

/// Describes vertex-based animations for a single mesh or a group of
/// meshes. Meshes carry the animation data for each frame in their
/// aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to
/// define keyframes linking each mesh attachment to a particular
/// point in time.
final class aiMeshAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wild-card to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.UnsignedInt()
  external int mNumKeys;

  /// Key frames of the animation. May not be nullptr.
  external ffi.Pointer<aiMeshKey> mKeys;
}

/// Describes a morphing animation of a given mesh.
final class aiMeshMorphAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wildcard to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.UnsignedInt()
  external int mNumKeys;

  /// Key frames of the animation. May not be nullptr.
  external ffi.Pointer<aiMeshMorphKey> mKeys;
}

/// An animation consists of key-frame data for a number of nodes. For
/// each node affected by the animation a separate series of data is given.
final class aiAnimation extends ffi.Struct {
  /// The name of the animation. If the modeling package this data was
  /// exported from does support only a single animation channel, this
  /// name is usually empty (length is zero).
  external aiString mName;

  /// Duration of the animation in ticks.
  @ffi.Double()
  external double mDuration;

  /// Ticks per second. 0 if not specified in the imported file
  @ffi.Double()
  external double mTicksPerSecond;

  /// The number of bone animation channels. Each channel affects
  /// a single node.
  @ffi.UnsignedInt()
  external int mNumChannels;

  /// The node animation channels. Each channel affects a single node.
  /// The array is mNumChannels in size.
  external ffi.Pointer<ffi.Pointer<aiNodeAnim>> mChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines vertex-based animation.
  @ffi.UnsignedInt()
  external int mNumMeshChannels;

  /// The mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshAnim>> mMeshChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines morphing animation.
  @ffi.UnsignedInt()
  external int mNumMorphMeshChannels;

  /// The morph mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMorphMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshMorphAnim>> mMorphMeshChannels;
}

/// The root structure of the imported data.
///
/// Everything that was imported from the given file can be accessed from here.
/// Objects of this class are generally maintained and owned by Assimp, not
/// by the caller. You shouldn't want to instance it, nor should you ever try to
/// delete a given scene on your own.
final class aiScene extends ffi.Struct {
  /// Any combination of the AI_SCENE_FLAGS_XXX flags. By default
  /// this value is 0, no flags are set. Most applications will
  /// want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
  /// bit set.
  @ffi.UnsignedInt()
  external int mFlags;

  /// The root node of the hierarchy.
  ///
  /// There will always be at least the root node if the import
  /// was successful (and no special flags have been set).
  /// Presence of further nodes depends on the format and content
  /// of the imported file.
  external ffi.Pointer<aiNode> mRootNode;

  /// The number of meshes in the scene.
  @ffi.UnsignedInt()
  external int mNumMeshes;

  /// The array of meshes.
  ///
  /// Use the indices given in the aiNode structure to access
  /// this array. The array is mNumMeshes in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMesh>> mMeshes;

  /// The number of materials in the scene.
  @ffi.UnsignedInt()
  external int mNumMaterials;

  /// The array of materials.
  ///
  /// Use the index given in each aiMesh structure to access this
  /// array. The array is mNumMaterials in size. If the
  /// AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
  /// be at least ONE material.
  external ffi.Pointer<ffi.Pointer<aiMaterial>> mMaterials;

  /// The number of animations in the scene.
  @ffi.UnsignedInt()
  external int mNumAnimations;

  /// The array of animations.
  ///
  /// All animations imported from the given file are listed here.
  /// The array is mNumAnimations in size.
  external ffi.Pointer<ffi.Pointer<aiAnimation>> mAnimations;

  /// The number of textures embedded into the file
  @ffi.UnsignedInt()
  external int mNumTextures;

  /// The array of embedded textures.
  ///
  /// Not many file formats embed their textures into the file.
  /// An example is Quake's MDL format (which is also used by
  /// some GameStudio versions)
  external ffi.Pointer<ffi.Pointer<aiTexture>> mTextures;

  /// The number of light sources in the scene. Light sources
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumLights;

  /// The array of light sources.
  ///
  /// All light sources imported from the given file are
  /// listed here. The array is mNumLights in size.
  external ffi.Pointer<ffi.Pointer<aiLight>> mLights;

  /// The number of cameras in the scene. Cameras
  /// are fully optional, in most cases this attribute will be 0
  @ffi.UnsignedInt()
  external int mNumCameras;

  /// The array of cameras.
  ///
  /// All cameras imported from the given file are listed here.
  /// The array is mNumCameras in size. The first camera in the
  /// array (if existing) is the default camera view into
  /// the scene.
  external ffi.Pointer<ffi.Pointer<aiCamera>> mCameras;

  /// @brief  The global metadata assigned to the scene itself.
  ///
  /// This data contains global metadata which belongs to the scene like
  /// unit-conversions, versions, vendors or other model-specific data. This
  /// can be used to store format-specific metadata as well.
  external ffi.Pointer<aiMetadata> mMetaData;

  /// The name of the scene itself.
  external aiString mName;

  ///
  @ffi.UnsignedInt()
  external int mNumSkeletons;

  ///
  external ffi.Pointer<ffi.Pointer<aiSkeleton>> mSkeletons;

  external ffi.Pointer<ffi.Char> mPrivate;
}

typedef aiFileReadProcFunction = ffi.Size Function(
    ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size);
typedef DartaiFileReadProcFunction = int Function(
    ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, int, int);
typedef aiFileReadProc
    = ffi.Pointer<ffi.NativeFunction<aiFileReadProcFunction>>;
typedef aiFileWriteProcFunction = ffi.Size Function(
    ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size);
typedef DartaiFileWriteProcFunction = int Function(
    ffi.Pointer<aiFile>, ffi.Pointer<ffi.Char>, int, int);
typedef aiFileWriteProc
    = ffi.Pointer<ffi.NativeFunction<aiFileWriteProcFunction>>;
typedef aiFileTellProcFunction = ffi.Size Function(ffi.Pointer<aiFile>);
typedef DartaiFileTellProcFunction = int Function(ffi.Pointer<aiFile>);
typedef aiFileTellProc
    = ffi.Pointer<ffi.NativeFunction<aiFileTellProcFunction>>;
typedef aiFileSeekFunction = ffi.Int Function(
    ffi.Pointer<aiFile>, ffi.Size, ffi.UnsignedInt);
typedef DartaiFileSeekFunction = aiReturn Function(
    ffi.Pointer<aiFile>, int, aiOrigin);
typedef aiFileSeek = ffi.Pointer<ffi.NativeFunction<aiFileSeekFunction>>;
typedef aiFileFlushProcFunction = ffi.Void Function(ffi.Pointer<aiFile>);
typedef DartaiFileFlushProcFunction = void Function(ffi.Pointer<aiFile>);
typedef aiFileFlushProc
    = ffi.Pointer<ffi.NativeFunction<aiFileFlushProcFunction>>;
typedef aiUserData = ffi.Pointer<ffi.Char>;

/// @brief C-API: File callbacks
///
/// Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)
/// replacement functions.
///
/// The default implementation of the functions utilizes the fXXX functions from
/// the CRT. However, you can supply a custom implementation to Assimp by
/// delivering a custom aiFileIO. Use this to enable reading from other sources,
/// such as ZIP archives or memory locations.
final class aiFile extends ffi.Struct {
  /// Callback to read from a file
  external aiFileReadProc ReadProc;

  /// Callback to write to a file
  external aiFileWriteProc WriteProc;

  /// Callback to retrieve the current position of
  /// the file cursor (ftell())
  external aiFileTellProc TellProc;

  /// Callback to retrieve the size of the file,
  /// in bytes
  external aiFileTellProc FileSizeProc;

  /// Callback to set the current position
  /// of the file cursor (fseek())
  external aiFileSeek SeekProc;

  /// Callback to flush the file contents
  external aiFileFlushProc FlushProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

typedef aiFileOpenProcFunction = ffi.Pointer<aiFile> Function(
    ffi.Pointer<aiFileIO>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>);
typedef aiFileOpenProc
    = ffi.Pointer<ffi.NativeFunction<aiFileOpenProcFunction>>;
typedef aiFileCloseProcFunction = ffi.Void Function(
    ffi.Pointer<aiFileIO>, ffi.Pointer<aiFile>);
typedef DartaiFileCloseProcFunction = void Function(
    ffi.Pointer<aiFileIO>, ffi.Pointer<aiFile>);
typedef aiFileCloseProc
    = ffi.Pointer<ffi.NativeFunction<aiFileCloseProcFunction>>;

/// @brief C-API: File system callbacks
///
/// Provided are functions to open and close files. Supply a custom structure to
/// the import function. If you don't, a default implementation is used. Use custom
/// file systems to enable reading from other sources, such as ZIPs
/// or memory locations.
final class aiFileIO extends ffi.Struct {
  /// Function used to open a new file
  external aiFileOpenProc OpenProc;

  /// Function used to close an existing file
  external aiFileCloseProc CloseProc;

  /// User-defined, opaque data
  external aiUserData UserData;
}

/// @brief  Describes an file format which Assimp can export to.
///
/// Use #aiGetExportFormatCount() to learn how many export-formats are supported by
/// the current Assimp-build and #aiGetExportFormatDescription() to retrieve the
/// description of the export format option.
final class aiExportFormatDesc extends ffi.Struct {
  /// a short string ID to uniquely identify the export format. Use this ID string to
  /// specify which file format you want to export to when calling #aiExportScene().
  /// Example: "dae" or "obj"
  external ffi.Pointer<ffi.Char> id;

  /// A short description of the file format to present to users. Useful if you want
  /// to allow the user to select an export format.
  external ffi.Pointer<ffi.Char> description;

  /// Recommended file extension for the exported file in lower case.
  external ffi.Pointer<ffi.Char> fileExtension;
}

/// Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an
/// exported scene. The memory referred by this structure is owned by Assimp.
/// to free its resources. Don't try to free the memory on your side - it will crash for most build configurations
/// due to conflicting heaps.
///
/// Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.
/// This is used when exporters write more than one output file for a given #aiScene. See the remarks for
/// #aiExportDataBlob::name for more information.
final class aiExportDataBlob extends ffi.Struct {
  /// Size of the data in bytes
  @ffi.Size()
  external int size;

  /// The data.
  external ffi.Pointer<ffi.Void> data;

  /// Name of the blob. An empty string always
  /// indicates the first (and primary) blob,
  /// which contains the actual file data.
  /// Any other blobs are auxiliary files produced
  /// by exporters (i.e. material files). Existence
  /// of such files depends on the file format. Most
  /// formats don't split assets across multiple files.
  ///
  /// If used, blob names usually contain the file
  /// extension that should be used when writing
  /// the data to disc.
  ///
  /// The blob names generated can be influenced by
  /// setting the #AI_CONFIG_EXPORT_BLOB_NAME export
  /// property to the name that is used for the master
  /// blob. All other names are typically derived from
  /// the base name, by the file format exporter.
  external aiString name;

  /// Pointer to the next blob in the chain or NULL if there is none.
  external ffi.Pointer<aiExportDataBlob> next;
}

/// Mixed set of flags for #aiImporterDesc, indicating some features
/// common to many importers
enum aiImporterFlags {
  /// Indicates that there is a textual encoding of the
  /// file format; and that it is supported.
  aiImporterFlags_SupportTextFlavour(1),

  /// Indicates that there is a binary encoding of the
  /// file format; and that it is supported.
  aiImporterFlags_SupportBinaryFlavour(2),

  /// Indicates that there is a compressed encoding of the
  /// file format; and that it is supported.
  aiImporterFlags_SupportCompressedFlavour(4),

  /// Indicates that the importer reads only a very particular
  /// subset of the file format. This happens commonly for
  /// declarative or procedural formats which cannot easily
  /// be mapped to #aiScene
  aiImporterFlags_LimitedSupport(8),

  /// Indicates that the importer is highly experimental and
  /// should be used with care. This only happens for trunk
  /// (i.e. SVN) versions, experimental code is not included
  /// in releases.
  aiImporterFlags_Experimental(16);

  final int value;
  const aiImporterFlags(this.value);

  static aiImporterFlags fromValue(int value) => switch (value) {
        1 => aiImporterFlags_SupportTextFlavour,
        2 => aiImporterFlags_SupportBinaryFlavour,
        4 => aiImporterFlags_SupportCompressedFlavour,
        8 => aiImporterFlags_LimitedSupport,
        16 => aiImporterFlags_Experimental,
        _ => throw ArgumentError('Unknown value for aiImporterFlags: $value'),
      };
}

/// Meta information about a particular importer. Importers need to fill
/// this structure, but they can freely decide how talkative they are.
/// A common use case for loader meta info is a user interface
/// in which the user can choose between various import/export file
/// formats. Building such an UI by hand means a lot of maintenance
/// as importers/exporters are added to Assimp, so it might be useful
/// to have a common mechanism to query some rough importer
/// characteristics.
final class aiImporterDesc extends ffi.Struct {
  /// Full name of the importer (i.e. Blender3D importer)
  external ffi.Pointer<ffi.Char> mName;

  /// Original author (left blank if unknown or whole assimp team)
  external ffi.Pointer<ffi.Char> mAuthor;

  /// Current maintainer, left blank if the author maintains
  external ffi.Pointer<ffi.Char> mMaintainer;

  /// Implementation comments, i.e. unimplemented features
  external ffi.Pointer<ffi.Char> mComments;

  /// These flags indicate some characteristics common to many
  /// importers.
  @ffi.UnsignedInt()
  external int mFlags;

  /// Minimum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care.
  @ffi.UnsignedInt()
  external int mMinMajor;

  @ffi.UnsignedInt()
  external int mMinMinor;

  /// Maximum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care. Loaders that expect to be
  /// forward-compatible to potential future format versions should
  /// indicate  zero, otherwise they should specify the current
  /// maximum version.
  @ffi.UnsignedInt()
  external int mMaxMajor;

  @ffi.UnsignedInt()
  external int mMaxMinor;

  /// List of file extensions this importer can handle.
  /// List entries are separated by space characters.
  /// All entries are lower case without a leading dot (i.e.
  /// "xml dae" would be a valid value. Note that multiple
  /// importers may respond to the same file extension -
  /// assimp calls all importers in the order in which they
  /// are registered and each importer gets the opportunity
  /// to load the file until one importer "claims" the file. Apart
  /// from file extension checks, importers typically use
  /// other methods to quickly reject files (i.e. magic
  /// words) so this does not mean that common or generic
  /// file extensions such as XML would be tediously slow.
  external ffi.Pointer<ffi.Char> mFileExtensions;
}

typedef aiLogStreamCallbackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>);
typedef DartaiLogStreamCallbackFunction = void Function(
    ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>);
typedef aiLogStreamCallback
    = ffi.Pointer<ffi.NativeFunction<aiLogStreamCallbackFunction>>;

/// C-API: Represents a log stream. A log stream receives all log messages and
/// streams them _somewhere_.
/// @see aiGetPredefinedLogStream
/// @see aiAttachLogStream
/// @see aiDetachLogStream
final class aiLogStream extends ffi.Struct {
  /// callback to be called
  external aiLogStreamCallback callback;

  /// user data to be passed to the callback
  external ffi.Pointer<ffi.Char> user;
}

/// C-API: Represents an opaque set of settings to be used during importing.
/// @see aiCreatePropertyStore
/// @see aiReleasePropertyStore
/// @see aiImportFileExWithProperties
/// @see aiSetPropertyInteger
/// @see aiSetPropertyFloat
/// @see aiSetPropertyString
/// @see aiSetPropertyMatrix
final class aiPropertyStore extends ffi.Struct {
  @ffi.Char()
  external int sentinel;
}

/// Our own C boolean type
typedef aiBool = ffi.Int;
typedef DartaiBool = int;

const String AI_CONFIG_GLOB_MEASURE_TIME = 'GLOB_MEASURE_TIME';

const String AI_CONFIG_IMPORT_NO_SKELETON_MESHES = 'IMPORT_NO_SKELETON_MESHES';

const String AI_CONFIG_PP_SBBC_MAX_BONES = 'PP_SBBC_MAX_BONES';

const int AI_SBBC_DEFAULT_MAX_BONES = 60;

const String AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE = 'PP_CT_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX =
    'PP_CT_TEXTURE_CHANNEL_INDEX';

const String AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE =
    'PP_GSN_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_IMPORT_MDL_COLORMAP = 'IMPORT_MDL_COLORMAP';

const String AI_CONFIG_PP_RRM_EXCLUDE_LIST = 'PP_RRM_EXCLUDE_LIST';

const String AI_CONFIG_PP_PTV_KEEP_HIERARCHY = 'PP_PTV_KEEP_HIERARCHY';

const String AI_CONFIG_PP_PTV_NORMALIZE = 'PP_PTV_NORMALIZE';

const String AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION =
    'PP_PTV_ADD_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION =
    'PP_PTV_ROOT_TRANSFORMATION';

const String AI_CONFIG_CHECK_IDENTITY_MATRIX_EPSILON =
    'CHECK_IDENTITY_MATRIX_EPSILON';

const double AI_CONFIG_CHECK_IDENTITY_MATRIX_EPSILON_DEFAULT =
    0.009999999776482582;

const String AI_CONFIG_PP_FD_REMOVE = 'PP_FD_REMOVE';

const String AI_CONFIG_PP_FD_CHECKAREA = 'PP_FD_CHECKAREA';

const String AI_CONFIG_PP_OG_EXCLUDE_LIST = 'PP_OG_EXCLUDE_LIST';

const String AI_CONFIG_PP_SLM_TRIANGLE_LIMIT = 'PP_SLM_TRIANGLE_LIMIT';

const int AI_SLM_DEFAULT_MAX_TRIANGLES = 1000000;

const String AI_CONFIG_PP_SLM_VERTEX_LIMIT = 'PP_SLM_VERTEX_LIMIT';

const int AI_SLM_DEFAULT_MAX_VERTICES = 1000000;

const String AI_CONFIG_PP_LBW_MAX_WEIGHTS = 'PP_LBW_MAX_WEIGHTS';

const int AI_LMW_MAX_WEIGHTS = 4;

const String AI_CONFIG_PP_DB_THRESHOLD = 'PP_DB_THRESHOLD';

const double AI_DEBONE_THRESHOLD = 1.0;

const String AI_CONFIG_PP_DB_ALL_OR_NONE = 'PP_DB_ALL_OR_NONE';

const String AI_CONFIG_PP_ICL_PTCACHE_SIZE = 'PP_ICL_PTCACHE_SIZE';

const String AI_CONFIG_PP_RVC_FLAGS = 'PP_RVC_FLAGS';

const String AI_CONFIG_PP_SBP_REMOVE = 'PP_SBP_REMOVE';

const String AI_CONFIG_PP_FID_ANIM_ACCURACY = 'PP_FID_ANIM_ACCURACY';

const String AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS =
    'PP_FID_IGNORE_TEXTURECOORDS';

const int AI_UVTRAFO_SCALING = 1;

const int AI_UVTRAFO_ROTATION = 2;

const int AI_UVTRAFO_TRANSLATION = 4;

const int AI_UVTRAFO_ALL = 7;

const String AI_CONFIG_PP_TUV_EVALUATE = 'PP_TUV_EVALUATE';

const String AI_CONFIG_FAVOUR_SPEED = 'FAVOUR_SPEED';

const String AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER =
    'IMPORT_SCHEMA_DOCUMENT_PROVIDER';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS =
    'IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS =
    'IMPORT_FBX_READ_ALL_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_MATERIALS = 'IMPORT_FBX_READ_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_TEXTURES = 'IMPORT_FBX_READ_TEXTURES';

const String AI_CONFIG_IMPORT_FBX_READ_CAMERAS = 'IMPORT_FBX_READ_CAMERAS';

const String AI_CONFIG_IMPORT_FBX_READ_LIGHTS = 'IMPORT_FBX_READ_LIGHTS';

const String AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS =
    'IMPORT_FBX_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_FBX_READ_WEIGHTS = 'IMPORT_FBX_READ_WEIGHTS';

const String AI_CONFIG_IMPORT_FBX_STRICT_MODE = 'IMPORT_FBX_STRICT_MODE';

const String AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS =
    'IMPORT_FBX_PRESERVE_PIVOTS';

const String AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES =
    'IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES';

const String AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING =
    'AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING';

const String AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES =
    'AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES';

const String AI_CONFIG_FBX_CONVERT_TO_M = 'AI_CONFIG_FBX_CONVERT_TO_M';

const String AI_CONFIG_IMPORT_FBX_IGNORE_UP_DIRECTION =
    'AI_CONFIG_IMPORT_FBX_IGNORE_UP_DIRECTION';

const String AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER =
    'AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER';

const String AI_CONFIG_IMPORT_GLOBAL_KEYFRAME = 'IMPORT_GLOBAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MD3_KEYFRAME = 'IMPORT_MD3_KEYFRAME';

const String AI_CONFIG_IMPORT_MD2_KEYFRAME = 'IMPORT_MD2_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_KEYFRAME = 'IMPORT_MDL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDC_KEYFRAME = 'IMPORT_MDC_KEYFRAME';

const String AI_CONFIG_IMPORT_SMD_KEYFRAME = 'IMPORT_SMD_KEYFRAME';

const String AI_CONFIG_IMPORT_UNREAL_KEYFRAME = 'IMPORT_UNREAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS =
    'IMPORT_MDL_HL1_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS =
    'IMPORT_MDL_HL1_READ_ANIMATION_EVENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_TRANSFORM_COORD_SYSTEM =
    'TRANSFORM COORDSYSTEM FOR HS! MODELS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS =
    'IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS =
    'IMPORT_MDL_HL1_READ_ATTACHMENTS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS =
    'IMPORT_MDL_HL1_READ_BONE_CONTROLLERS';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES =
    'IMPORT_MDL_HL1_READ_HITBOXES';

const String AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO =
    'IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO';

const String AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST =
    'IMPORT_SMD_LOAD_ANIMATION_LIST';

const String AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL = 'IMPORT_AC_SEPARATE_BFCULL';

const String AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION =
    'IMPORT_AC_EVAL_SUBDIVISION';

const String AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS = 'UNREAL_HANDLE_FLAGS';

const String AI_CONFIG_IMPORT_TER_MAKE_UVS = 'IMPORT_TER_MAKE_UVS';

const String AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS =
    'IMPORT_ASE_RECONSTRUCT_NORMALS';

const String AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART =
    'IMPORT_MD3_HANDLE_MULTIPART';

const String AI_CONFIG_IMPORT_MD3_SKIN_NAME = 'IMPORT_MD3_SKIN_NAME';

const String AI_CONFIG_IMPORT_MD3_LOAD_SHADERS = 'IMPORT_MD3_LOAD_SHADERS';

const String AI_CONFIG_IMPORT_MD3_SHADER_SRC = 'IMPORT_MD3_SHADER_SRC';

const String AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY = 'IMPORT_LWO_ONE_LAYER_ONLY';

const String AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD =
    'IMPORT_MD5_NO_ANIM_AUTOLOAD';

const String AI_CONFIG_IMPORT_LWS_ANIM_START = 'IMPORT_LWS_ANIM_START';

const String AI_CONFIG_IMPORT_LWS_ANIM_END = 'IMPORT_LWS_ANIM_END';

const String AI_CONFIG_IMPORT_IRR_ANIM_FPS = 'IMPORT_IRR_ANIM_FPS';

const String AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE = 'IMPORT_OGRE_MATERIAL_FILE';

const String AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME =
    'IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME';

const String AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT =
    'AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT';

const String AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS =
    'IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS';

const String AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION =
    'IMPORT_IFC_CUSTOM_TRIANGULATION';

const String AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE =
    'IMPORT_IFC_SMOOTHING_ANGLE';

const double AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE = 10.0;

const String AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION =
    'IMPORT_IFC_CYLINDRICAL_TESSELLATION';

const int AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION = 32;

const String AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION =
    'IMPORT_COLLADA_IGNORE_UP_DIRECTION';

const String AI_CONFIG_IMPORT_COLLADA_IGNORE_UNIT_SIZE =
    'IMPORT_COLLADA_IGNORE_UNIT_SIZE';

const String AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES =
    'IMPORT_COLLADA_USE_COLLADA_NAMES';

const String AI_CONFIG_EXPORT_XFILE_64BIT = 'EXPORT_XFILE_64BIT';

const String AI_CONFIG_EXPORT_POINT_CLOUDS = 'EXPORT_POINT_CLOUDS';

const String AI_CONFIG_USE_GLTF_PBR_SPECULAR_GLOSSINESS =
    'USE_GLTF_PBR_SPECULAR_GLOSSINESS';

const String AI_CONFIG_EXPORT_GLTF_UNLIMITED_SKINNING_BONES_PER_VERTEX =
    'USE_UNLIMITED_BONES_PER VERTEX';

const String AI_CONFIG_EXPORT_FBX_TRANSPARENCY_FACTOR_REFER_TO_OPACITY =
    'EXPORT_FBX_TRANSPARENCY_FACTOR_REFER_TO_OPACITY';

const String AI_CONFIG_EXPORT_BLOB_NAME = 'EXPORT_BLOB_NAME';

const String AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY = 'GLOBAL_SCALE_FACTOR';

const double AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT = 1.0;

const String AI_CONFIG_APP_SCALE_KEY = 'APP_SCALE_FACTOR';

const double AI_MATH_PI = 3.141592653589793;

const double AI_MATH_TWO_PI = 6.283185307179586;

const double AI_MATH_HALF_PI = 1.5707963267948966;

const double AI_MATH_PI_F = 3.1415927410125732;

const double AI_MATH_TWO_PI_F = 6.2831854820251465;

const double AI_MATH_HALF_PI_F = 1.5707963705062866;

const int AI_MAXLEN = 1024;

const int AI_SUCCESS = 0;

const int AI_FAILURE = -1;

const int AI_OUTOFMEMORY = -3;

const String AI_EMBEDDED_TEXNAME_PREFIX = '*';

const int AI_MAX_FACE_INDICES = 32767;

const int AI_MAX_BONE_WEIGHTS = 2147483647;

const int AI_MAX_VERTICES = 2147483647;

const int AI_MAX_FACES = 2147483647;

const int AI_MAX_NUMBER_OF_COLOR_SETS = 8;

const int AI_MAX_NUMBER_OF_TEXTURECOORDS = 8;

const String AI_DEFAULT_MATERIAL_NAME = 'DefaultMaterial';

const int AI_TEXTURE_TYPE_MAX = 27;

const String AI_MATKEY_NAME = '?mat.name';

const String AI_MATKEY_TWOSIDED = '\$mat.twosided';

const String AI_MATKEY_SHADING_MODEL = '\$mat.shadingm';

const String AI_MATKEY_ENABLE_WIREFRAME = '\$mat.wireframe';

const String AI_MATKEY_BLEND_FUNC = '\$mat.blend';

const String AI_MATKEY_OPACITY = '\$mat.opacity';

const String AI_MATKEY_TRANSPARENCYFACTOR = '\$mat.transparencyfactor';

const String AI_MATKEY_BUMPSCALING = '\$mat.bumpscaling';

const String AI_MATKEY_SHININESS = '\$mat.shininess';

const String AI_MATKEY_REFLECTIVITY = '\$mat.reflectivity';

const String AI_MATKEY_SHININESS_STRENGTH = '\$mat.shinpercent';

const String AI_MATKEY_REFRACTI = '\$mat.refracti';

const String AI_MATKEY_COLOR_DIFFUSE = '\$clr.diffuse';

const String AI_MATKEY_COLOR_AMBIENT = '\$clr.ambient';

const String AI_MATKEY_COLOR_SPECULAR = '\$clr.specular';

const String AI_MATKEY_COLOR_EMISSIVE = '\$clr.emissive';

const String AI_MATKEY_COLOR_TRANSPARENT = '\$clr.transparent';

const String AI_MATKEY_COLOR_REFLECTIVE = '\$clr.reflective';

const String AI_MATKEY_GLOBAL_BACKGROUND_IMAGE = '?bg.global';

const String AI_MATKEY_GLOBAL_SHADERLANG = '?sh.lang';

const String AI_MATKEY_SHADER_VERTEX = '?sh.vs';

const String AI_MATKEY_SHADER_FRAGMENT = '?sh.fs';

const String AI_MATKEY_SHADER_GEO = '?sh.gs';

const String AI_MATKEY_SHADER_TESSELATION = '?sh.ts';

const String AI_MATKEY_SHADER_PRIMITIVE = '?sh.ps';

const String AI_MATKEY_SHADER_COMPUTE = '?sh.cs';

const String AI_MATKEY_USE_COLOR_MAP = '\$mat.useColorMap';

const String AI_MATKEY_BASE_COLOR = '\$clr.base';

const int AI_MATKEY_BASE_COLOR_TEXTURE = 12;

const String AI_MATKEY_USE_METALLIC_MAP = '\$mat.useMetallicMap';

const String AI_MATKEY_METALLIC_FACTOR = '\$mat.metallicFactor';

const int AI_MATKEY_METALLIC_TEXTURE = 15;

const String AI_MATKEY_USE_ROUGHNESS_MAP = '\$mat.useRoughnessMap';

const String AI_MATKEY_ROUGHNESS_FACTOR = '\$mat.roughnessFactor';

const int AI_MATKEY_ROUGHNESS_TEXTURE = 16;

const String AI_MATKEY_ANISOTROPY_FACTOR = '\$mat.anisotropyFactor';

const String AI_MATKEY_SPECULAR_FACTOR = '\$mat.specularFactor';

const String AI_MATKEY_GLOSSINESS_FACTOR = '\$mat.glossinessFactor';

const String AI_MATKEY_SHEEN_COLOR_FACTOR = '\$clr.sheen.factor';

const String AI_MATKEY_SHEEN_ROUGHNESS_FACTOR = '\$mat.sheen.roughnessFactor';

const int AI_MATKEY_SHEEN_COLOR_TEXTURE = 19;

const int AI_MATKEY_SHEEN_ROUGHNESS_TEXTURE = 19;

const String AI_MATKEY_CLEARCOAT_FACTOR = '\$mat.clearcoat.factor';

const String AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR =
    '\$mat.clearcoat.roughnessFactor';

const int AI_MATKEY_CLEARCOAT_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_ROUGHNESS_TEXTURE = 20;

const int AI_MATKEY_CLEARCOAT_NORMAL_TEXTURE = 20;

const String AI_MATKEY_TRANSMISSION_FACTOR = '\$mat.transmission.factor';

const int AI_MATKEY_TRANSMISSION_TEXTURE = 21;

const String AI_MATKEY_VOLUME_THICKNESS_FACTOR = '\$mat.volume.thicknessFactor';

const int AI_MATKEY_VOLUME_THICKNESS_TEXTURE = 21;

const String AI_MATKEY_VOLUME_ATTENUATION_DISTANCE =
    '\$mat.volume.attenuationDistance';

const String AI_MATKEY_VOLUME_ATTENUATION_COLOR =
    '\$mat.volume.attenuationColor';

const String AI_MATKEY_USE_EMISSIVE_MAP = '\$mat.useEmissiveMap';

const String AI_MATKEY_EMISSIVE_INTENSITY = '\$mat.emissiveIntensity';

const String AI_MATKEY_USE_AO_MAP = '\$mat.useAOMap';

const String AI_MATKEY_ANISOTROPY_ROTATION = '\$mat.anisotropyRotation';

const int AI_MATKEY_ANISOTROPY_TEXTURE = 26;

const int AI_SCENE_FLAGS_INCOMPLETE = 1;

const int AI_SCENE_FLAGS_VALIDATED = 2;

const int AI_SCENE_FLAGS_VALIDATION_WARNING = 4;

const int AI_SCENE_FLAGS_NON_VERBOSE_FORMAT = 8;

const int AI_SCENE_FLAGS_TERRAIN = 16;

const int AI_SCENE_FLAGS_ALLOW_SHARED = 32;

const int AI_FALSE = 0;

const int AI_TRUE = 1;

#include <QtCore>

#include <assimp/cimport.h>
#include <assimp/scene.h>

static QDir testFileDir() { return QDir::current(); }
static QString testFilePath(const QString &fileName) { return testFileDir().filePath(fileName); }

static QDir testModelDir() { return QDir(QDir::currentPath() + "/models/model-db/"); }
static QString testModelPath(const QString &fileName) { return testModelDir().filePath(fileName); }

static QString import(const QString &package) { return QString("import '%1';").arg(package); }

static QString isZeroOrNot(int num) { return num ? "isNonZero" : "isZero"; }
static QString isNullOrNot(void *ptr) { return ptr ? "isNotNull" : "isNull"; }

static QString equalsTo(const QString &value) { return QString("equals(%1)").arg(value); }
static QString equalsToInt(int value) { return value ? QString("equals(%1)").arg(value) : "isZero"; }
static QString equalsToFloat(float value) { return qFuzzyIsNull(value) ? "isZero" : QString("moreOrLessEquals(%1)").arg(value); }
static QString equalsToDouble(double value) { return qFuzzyIsNull(value) ? "isZero" : QString("moreOrLessEquals(%1)").arg(value); }
static QString equalsToString(const char *str, uint len) { return len ? QString("equals('%1')").arg(QString::fromUtf8(str, len).replace("\\", "\\\\").replace("$", "\\$")) : "isEmpty"; }
static QString equalsToString(const aiString &str) { return equalsToString(str.data, str.length); }
static QString equalsToQuaternion(const aiQuaternion &q) { return QString("quaternionMoreOrLessEquals(Quaternion(%1, %2, %3, %4))").arg(q.x).arg(q.y).arg(q.z).arg(q.z); }
static QString equalsToVector3(const aiVector3D &v) { return QString("vector3MoreOrLessEquals(Vector3(%1, %2, %3))").arg(v.x).arg(v.y).arg(v.z); }
static QString equalsToMatrix4(const aiMatrix4x4 &m) { return QString("matrix4MoreOrLessEquals(Matrix4(%1, %2, %3, %4, %5 ,%6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16))").arg(m.a1).arg(m.a2).arg(m.a3).arg(m.a4).arg(m.b1).arg(m.b2).arg(m.b3).arg(m.b4).arg(m.c1).arg(m.c2).arg(m.c3).arg(m.c4).arg(m.d1).arg(m.d2).arg(m.d3).arg(m.d4); }
static QString equalsToByteArray(const char *arr, uint len) { QStringList v; for (uint i = 0; i < len; ++i) v += QString::number(arr[i]); return QString("equals([%1])").arg(v.join(", ")); }
static QString equalsToIntArray(const uint *arr, uint len) { QStringList v; for (uint i = 0; i < len; ++i) v += QString::number(arr[i]); return QString("equals([%1])").arg(v.join(", ")); }
static QString equalsToDoubleArray(const double *arr, uint len) { QStringList v; for (uint i = 0; i < len; ++i) v += QString::number(arr[i]); return QString("equals([%1])").arg(v.join(", ")); }

static QString equalsToAnimBehavior(int value)
{
    switch (value) {
    case aiAnimBehaviour_DEFAULT: return equalsTo("AnimBehavior.defaults");
    case aiAnimBehaviour_CONSTANT: return equalsTo("AnimBehavior.constant");
    case aiAnimBehaviour_LINEAR: return equalsTo("AnimBehavior.linear");
    case aiAnimBehaviour_REPEAT: return equalsTo("AnimBehavior.repeat");
    default: return QString();
    }
}

template <typename T>
static int arraySize(T *array)
{
    int c = 0;
    while (array[c] != 0)
        ++c;
    return c;
}

static void writeHeader(QTextStream &out, const QString &fileName)
{
    Q_UNUSED(fileName);
    out << import("dart:ffi") << "\n"
        << import("dart:typed_data") << "\n"
        << import("package:ffi/ffi.dart") << "\n"
        << import("package:test/test.dart") << "\n"
        << import("package:assimp/assimp.dart") << "\n"
        << import("../lib/src/bindings.dart") << "\n"
        << import("test_utils.dart") << "\n\n"
        << "// DO NOT EDIT (generated by tool/testgen)\n\n"
        << "void main() {\n"
        << "  prepareTest();\n\n";
}

static void writeFooter(QTextStream &out, const QString &fileName)
{
    Q_UNUSED(fileName);
    out << "}\n";
}

static void writeGroup(QTextStream &out, const QString &name, std::function<void()> writer)
{
    out << QString("  test('%1', () {\n").arg(name);
    writer();
    out << "  });\n\n";
}

static void writeNullTest(QTextStream &out, const QString &name)
{
    writeGroup(out, "null", [&]() {
        out << QString("    expect(%1.fromNative(null), isNull);\n").arg(name.mid(2));
    });
}

static void writeSizeTest(QTextStream &out, const QString &name, size_t size)
{
    writeGroup(out, "size", [&]() {
        out << QString("    expect(sizeOf<%1>(), equals(%2));\n").arg(name).arg(size);
    });
}

template <typename T>
static void generateTest(const QString &typeName, const QString &fileName, std::function<void(QTextStream &out)> writer)
{
    QFile file(testFilePath(fileName));
    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate))
        qFatal(qPrintable(file.errorString()));

    QTextStream out(&file);
    writeHeader(out, fileName);
    writeNullTest(out, typeName);
    writeSizeTest(out, typeName, sizeof(T));
    writer(out);
    writeFooter(out, fileName);
}

static void writeAnimationTester(QTextStream &out, const QString &fileName = QString())
{
    const aiScene *scene = aiImportFile(testModelPath(fileName).toLocal8Bit(), 0);
    out << "    testAnimations('" << fileName << "', (animations) {\n"
        << "      expect(animations.length, " << equalsToInt(scene->mNumAnimations) << ");\n";
    for (uint i = 0; i < scene->mNumAnimations; ++i) {
        const aiAnimation *animation = scene->mAnimations[i];
        out << "      expect(animations.elementAt(" << i << ").name, " << equalsToString(animation->mName) << ");\n";
        out << "      expect(animations.elementAt(" << i << ").duration, " << equalsToDouble(animation->mDuration) << ");\n";
        out << "      expect(animations.elementAt(" << i << ").ticksPerSecond, " << equalsToDouble(animation->mTicksPerSecond) << ");\n";
        out << "      expect(animations.elementAt(" << i << ").channels.length, " << equalsToInt(animation->mNumChannels) << ");\n";
        for (uint j = 0; j < animation->mNumChannels; ++j) {
            const aiNodeAnim *channel = animation->mChannels[j];
            out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").positionKeys.length, " << equalsToInt(channel->mNumPositionKeys) << ");\n";
            for (uint k = 0; k < channel->mNumPositionKeys; ++k) {
                const aiVectorKey *key = channel->mPositionKeys + k;
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").positionKeys.elementAt(" << k << ").time, " << equalsToDouble(key->mTime) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").positionKeys.elementAt(" << k << ").value, " << equalsToVector3(key->mValue) << ");\n";
            }
            out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").rotationKeys.length, " << equalsToInt(channel->mNumRotationKeys) << ");\n";
            for (uint k = 0; k < channel->mNumRotationKeys; ++k) {
                const aiQuatKey *key = channel->mRotationKeys + k;
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").rotationKeys.elementAt(" << k << ").time, " << equalsToDouble(key->mTime) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").rotationKeys.elementAt(" << k << ").value, " << equalsToQuaternion(key->mValue) << ");\n";
            }
            out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").scalingKeys.length, " << equalsToInt(channel->mNumScalingKeys) << ");\n";
            for (uint k = 0; k < channel->mNumScalingKeys; ++k) {
                const aiVectorKey *key = channel->mScalingKeys + k;
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").scalingKeys.elementAt(" << k << ").time, " << equalsToDouble(key->mTime) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").scalingKeys.elementAt(" << k << ").value, " << equalsToVector3(key->mValue) << ");\n";
            }
            out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").preState, " << equalsToAnimBehavior(channel->mPreState) << ");\n";
            out << "      expect(animations.elementAt(" << i << ").channels.elementAt(" << j << ").postState, " << equalsToAnimBehavior(channel->mPostState) << ");\n";
        }
        out << "      expect(animations.elementAt(" << i << ").meshChannels.length, " << equalsToInt(animation->mNumMeshChannels) << ");\n";
        for (uint j = 0; j < animation->mNumMeshChannels; ++j) {
            const aiMeshAnim *channel = animation->mMeshChannels[j];
            out << "      expect(animations.elementAt(" << i << ").meshChannels.elementAt(" << j << ").keys.length, " << equalsToInt(channel->mNumKeys) << ");\n";
            for (uint k = 0; k < channel->mNumKeys; ++k) {
                const aiMeshKey *key = channel->mKeys + k;
                out << "      expect(animations.elementAt(" << i << ").meshChannels.elementAt(" << j << ").keys.elementAt(" << k << ").time, " << equalsToDouble(key->mTime) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").meshChannels.elementAt(" << j << ").keys.elementAt(" << k << ").value, " << equalsToInt(key->mValue) << ");\n";
            }
        }
        out << "      expect(animations.elementAt(" << i << ").meshMorphChannels.length, " << equalsToInt(animation->mNumMorphMeshChannels) << ");\n";
        for (uint j = 0; j < animation->mNumMorphMeshChannels; ++j) {
            const aiMeshMorphAnim *channel = animation->mMorphMeshChannels[j];
            out << "      expect(animations.elementAt(" << i << ").meshMorphChannels.elementAt(" << j << ").keys.length, " << equalsToInt(channel->mNumKeys) << ");\n";
            for (uint k = 0; k < channel->mNumKeys; ++k) {
                const aiMeshMorphKey *key = channel->mKeys + k;
                out << "      expect(animations.elementAt(" << i << ").meshMorphChannels.elementAt(" << j << ").keys.elementAt(" << k << ").time, " << equalsToDouble(key->mTime) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").meshMorphChannels.elementAt(" << j << ").keys.elementAt(" << k << ").values, " << equalsToIntArray(key->mValues, key->mNumValuesAndWeights) << ");\n";
                out << "      expect(animations.elementAt(" << i << ").meshMorphChannels.elementAt(" << j << ").keys.elementAt(" << k << ").weights, " << equalsToDoubleArray(key->mWeights, key->mNumValuesAndWeights) << ");\n";
            }
        }
        out << (i < scene->mNumAnimations - 1 ? "\n" : "");
    }
    out << "    });\n";
    aiReleaseImport(scene);
}

static void generateAnimationTest(const QString &fileName)
{
    generateTest<aiAnimation>("aiAnimation", fileName, [&](QTextStream &out) {
        writeGroup(out, "3mf", [&]() {
            writeAnimationTester(out, "3mf/box.3mf");
            writeAnimationTester(out, "3mf/spider.3mf");
        });
        writeGroup(out, "fbx", [&]() {
            writeAnimationTester(out, "fbx/huesitos.fbx");
        });
        writeGroup(out, "obj", [&]() {
            writeAnimationTester(out, "Obj/Spider/spider.obj");
        });
    });
}

static void writeMaterialTester(QTextStream &out, const QString &fileName = QString())
{
    const aiScene *scene = aiImportFile(testModelPath(fileName).toLocal8Bit(), 0);
    out << "    testMaterials('" << fileName << "', (materials) {\n"
        << "      expect(materials.length, " << equalsToInt(scene->mNumMaterials) << ");\n";
    for (uint i = 0; i < scene->mNumMaterials; ++i) {
        const aiMaterial *material = scene->mMaterials[i];
        out << "      expect(materials.elementAt(" << i << ").properties.length, " << equalsToInt(material->mNumProperties) << ");\n";
        for (uint j = 0; j < material->mNumProperties; ++j) {
            const aiMaterialProperty *property = material->mProperties[j];
            out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").key, " << equalsToString(property->mKey) << ");\n";
            switch (property->mType) {
            case aiPropertyTypeInfo::aiPTI_Float:
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value.runtimeType, double);\n";
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value, " << equalsToFloat(*reinterpret_cast<float*>(property->mData)) << ");\n";
                break;
            case aiPropertyTypeInfo::aiPTI_Double:
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value.runtimeType, double);\n";
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value, " << equalsToDouble(*reinterpret_cast<double*>(property->mData)) << ");\n";
                break;
            case aiPropertyTypeInfo::aiPTI_String:
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value.runtimeType, String);\n";
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value, " << equalsToString(*reinterpret_cast<aiString*>(property->mData)) << ");\n";
                break;
            case aiPropertyTypeInfo::aiPTI_Integer:
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value.runtimeType, int);\n";
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value, " << equalsToInt(*reinterpret_cast<int*>(property->mData)) << ");\n";
                break;
            case aiPropertyTypeInfo::aiPTI_Buffer:
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value.runtimeType.toString(), 'Uint8List');\n";
                out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").value, " << equalsToByteArray(property->mData, property->mDataLength) << ");\n";
                break;
            default:
                break;
            }
            out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").index, " << equalsToInt(property->mIndex) << ");\n";
            out << "        expect(materials.elementAt(" << i << ").properties.elementAt(" << j << ").semantic, " << equalsToInt(property->mSemantic) << ");\n";
        }
        out << (i < scene->mNumMaterials - 1 ? "\n" : "");
    }
    out << "    });\n";
    aiReleaseImport(scene);
}

static void generateMaterialTest(const QString &fileName)
{
    generateTest<aiMaterial>("aiMaterial", fileName, [&](QTextStream &out) {
        writeGroup(out, "3mf", [&]() {
            writeMaterialTester(out, "3mf/box.3mf");
            writeMaterialTester(out, "3mf/spider.3mf");
        });
        writeGroup(out, "fbx", [&]() {
            writeMaterialTester(out, "fbx/huesitos.fbx");
        });
        writeGroup(out, "obj", [&]() {
            writeMaterialTester(out, "Obj/Spider/spider.obj");
        });
    });
}

static void writeMeshTester(QTextStream &out, const QString &fileName = QString())
{
    const aiScene *scene = aiImportFile(testModelPath(fileName).toLocal8Bit(), 0);
    out << "    testMeshes('" << fileName << "', (meshes) {\n"
        << "      expect(meshes.length, " << equalsToInt(scene->mNumMeshes) << ");\n";
    for (uint i = 0; i < scene->mNumMeshes; ++i) {
        const aiMesh *mesh = scene->mMeshes[i];
        out << "      expect(meshes.elementAt(" << i << ").primitiveTypes, " << equalsToInt(mesh->mPrimitiveTypes) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").vertices.length, " << equalsToInt(mesh->mNumVertices) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").normals.length, " << equalsToInt(mesh->mNumVertices) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").tangents.length, " << equalsToInt(mesh->mNumVertices) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").bitangents.length, " << equalsToInt(mesh->mNumVertices) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").colors.length, " << equalsToInt(arraySize(mesh->mColors)) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").textureCoords.length, " << equalsToInt(arraySize(mesh->mTextureCoords)) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").uvComponents.length, " << equalsToInt(arraySize(mesh->mNumUVComponents)) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").faces.length, " << equalsToInt(mesh->mNumFaces) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").bones.length, " << equalsToInt(mesh->mNumBones) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").materialIndex, " << equalsToInt(mesh->mMaterialIndex) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").name, " << equalsToString(mesh->mName) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").animMeshes.length, " << equalsToInt(mesh->mNumAnimMeshes) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").morphingMethod, " << equalsToInt(mesh->mMethod) << ");\n"
            << "      expect(meshes.elementAt(" << i << ").aabb, isNull);\n" // ### TODO
            << (i < scene->mNumMeshes - 1 ? "\n" : "");
    }
    out << "    });\n";
    aiReleaseImport(scene);
}

static void generateMeshTest(const QString &fileName)
{
    generateTest<aiMesh>("aiMesh", fileName, [&](QTextStream &out) {
        writeGroup(out, "3mf", [&]() {
            writeMeshTester(out, "3mf/box.3mf");
            writeMeshTester(out, "3mf/spider.3mf");
        });
        writeGroup(out, "fbx", [&]() {
            writeMeshTester(out, "fbx/huesitos.fbx");
        });
        writeGroup(out, "obj", [&]() {
            writeMeshTester(out, "Obj/Spider/spider.obj");
        });
    });
}

static void writeNodeTester(QTextStream &out, const QString &fileName = QString())
{
    const aiScene *scene = aiImportFile(testModelPath(fileName).toLocal8Bit(), 0);
    out << "    testNodes('" << fileName << "', (rootNode) {\n"
        << "      expect(rootNode.name, " << equalsToString(scene->mRootNode->mName) << ");\n"
        << "      expect(rootNode.transformation, " << equalsToMatrix4(scene->mRootNode->mTransformation) << ");\n"
        << "      expect(rootNode.parent, " << isNullOrNot(scene->mRootNode->mParent) << ");\n"
        << "      expect(rootNode.children.length, " << equalsToInt(scene->mRootNode->mNumChildren) << ");\n";
    for (uint i = 0; i < scene->mRootNode->mNumChildren; ++i) {
        const aiNode *node = scene->mRootNode->mChildren[i];
        out << "      expect(rootNode.children.elementAt(" << i << ").name, " << equalsToString(node->mName) << ");\n"
            << "      expect(rootNode.children.elementAt(" << i << ").transformation, " << equalsToMatrix4(node->mTransformation) << ");\n"
            << "      expect(rootNode.children.elementAt(" << i << ").parent, " << isNullOrNot(node->mParent) << ");\n"
            << "      expect(rootNode.children.elementAt(" << i << ").children.length, " << equalsToInt(node->mNumChildren) << ");\n"
            << "      expect(rootNode.children.elementAt(" << i << ").meshes, " << equalsToIntArray(node->mMeshes, node->mNumMeshes) << ");\n"
            << "      expect(rootNode.children.elementAt(" << i << ").metaData, " << isNullOrNot(node->mMetaData) << ");\n";
    }
    out << "      expect(rootNode.meshes, " << equalsToIntArray(scene->mRootNode->mMeshes, scene->mRootNode->mNumMeshes) << ");\n"
        << "      expect(rootNode.metaData, " << isNullOrNot(scene->mRootNode->mMetaData) << ");\n"
        << "    });\n\n";
    aiReleaseImport(scene);
}

static void generateNodeTest(const QString &fileName)
{
    generateTest<aiNode>("aiNode", fileName, [&](QTextStream &out) {
        writeGroup(out, "3mf", [&]() {
            writeNodeTester(out, "3mf/box.3mf");
            writeNodeTester(out, "3mf/spider.3mf");
        });
        writeGroup(out, "fbx", [&]() {
            writeNodeTester(out, "fbx/huesitos.fbx");
        });
        writeGroup(out, "obj", [&]() {
            writeNodeTester(out, "Obj/Spider/spider.obj");
        });
    });
}

static void writeSceneTester(QTextStream &out, const QString &fileName = QString())
{
    const aiScene *scene = aiImportFile(testModelPath(fileName).toLocal8Bit(), 0);
    out << "    testScene('" << fileName << "', tester: (scene) {\n"
        << "      expect(scene.flags, " << isZeroOrNot(scene->mFlags) << ");\n"
        << "      expect(scene.rootNode, " << isNullOrNot(scene->mRootNode) << ");\n"
        << "      expect(scene.meshes.length, " << equalsToInt(scene->mNumMeshes) << ");\n"
        << "      expect(scene.materials.length, " << equalsToInt(scene->mNumMaterials) << ");\n"
        << "      expect(scene.animations.length, " << equalsToInt(scene->mNumAnimations) << ");\n"
        << "      expect(scene.textures.length, " << equalsToInt(scene->mNumTextures) << ");\n"
        << "      expect(scene.lights.length, " << equalsToInt(scene->mNumLights) << ");\n"
        << "      expect(scene.cameras.length, " << equalsToInt(scene->mNumCameras) << ");\n"
        << "      expect(scene.metaData, " << isNullOrNot(scene->mMetaData) << ");\n"
        << "    });\n";
    aiReleaseImport(scene);
}

static void generateSceneTest(const QString &fileName)
{
    generateTest<aiScene>("aiScene", fileName, [&](QTextStream &out) {
        writeGroup(out, "3mf", [&]() {
            writeSceneTester(out, "3mf/box.3mf");
            writeSceneTester(out, "3mf/spider.3mf");
        });
        writeGroup(out, "fbx", [&]() {
            writeSceneTester(out, "fbx/huesitos.fbx");
        });
        writeGroup(out, "obj", [&]() {
            writeSceneTester(out, "Obj/Spider/spider.obj");
        });
    });
}

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    QDir::setCurrent(QString::fromLocal8Bit(argc > 1 ? argv[1] : OUT_PWD));

    generateAnimationTest("animation_test.dart");
    generateMaterialTest("material_test.dart");
    generateMeshTest("mesh_test.dart");
    generateNodeTest("node_test.dart");
    generateSceneTest("scene_test.dart");
}
